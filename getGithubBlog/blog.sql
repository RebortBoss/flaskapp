-- MySQL dump 10.13  Distrib 5.5.29, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.5.29-0ubuntu0.12.10.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `blog_entries`
--

DROP TABLE IF EXISTS `blog_entries`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_entries` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(500) NOT NULL,
  `text` text,
  `href` varchar(500) NOT NULL,
  `oriId` varchar(500) DEFAULT NULL,
  `des` text,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_entries`
--

/*!40000 ALTER TABLE `blog_entries` DISABLE KEYS */;
INSERT INTO `blog_entries` VALUES (1,'gnome popup Box message.md','<h1>\n<a name=\"gnome-popup-box-message-\" class=\"anchor\" href=\"#gnome-popup-box-message-\"><span class=\"mini-icon mini-icon-link\"></span></a>gnome popup Box message </h1>\n\n<p>之前写一些要用的脚本的时候.苦于没有找到方便的可视化消息通知方法\n之前的做法是是使用pyqt 写一些简单的message box 可以见<a href=\"https://github.com/xiyoulaoyuanjia/GetVdiskLink\">这里</a></p>\n\n<p>后来在<a href=\"http://smashingweb.info/send-messages-over-network-gnome-popup-box-message/\">这里</a>\n发现了gnome下的一些常用的Box message  方法。感觉用着很舒服。。这里推荐给大家</p>\n\n<p><strong>zenity:It will display a default ok box on the screen</strong></p>\n\n<blockquote>\n<ul>\n<li>display  GTK+ dialogs</li>\n<li> 输出 ”message here“ 信息</li>\n</ul>\n</blockquote>\n\n<pre><code>zenity --info --text \"message here\"\n</code></pre>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/167669823dbc8cdfe3326e09efe7ea9401b290d4/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d64623932554b70734638485563777031554854746665796857346b7958396765625955385a366742566b545248547235466d593178506f5a5a7a5a2d2d32462d2d32424d6c33785757694f2d2d3242673563546f382d2d32465a38325276636b4542654f49624d63\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/167669823dbc8cdfe3326e09efe7ea9401b290d4/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d64623932554b70734638485563777031554854746665796857346b7958396765625955385a366742566b545248547235466d593178506f5a5a7a5a2d2d32462d2d32424d6c33785757694f2d2d3242673563546f382d2d32465a38325276636b4542654f49624d63\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<blockquote>\n<ul>\n<li>输出gtk标准日历</li>\n</ul>\n</blockquote>\n\n<pre><code>zenity  --calendar\n</code></pre>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/c1f7711528736b26440a7cbf42463aca2bed753a/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d38646136594c734459436e7a7a3937624430702d2d32425657544a697042374a6170364b4632364355543159616a594a7a6a6878646e724f665a42576666684679714d4b62663569664b4c307953314f393436436c62416f62662d2d324677374644\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/c1f7711528736b26440a7cbf42463aca2bed753a/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d38646136594c734459436e7a7a3937624430702d2d32425657544a697042374a6170364b4632364355543159616a594a7a6a6878646e724f665a42576666684679714d4b62663569664b4c307953314f393436436c62416f62662d2d324677374644\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>更详细的用法参见 man zenity</p>\n\n<p>这里有一篇<a href=\"http://en.wikipedia.org/wiki/Zenity\">wikipedia 的介绍</a></p>\n\n<p><strong>notify-send:系统提示托盘</strong></p>\n\n<blockquote>\n<ul>\n<li><p>notify-send [\"title\"] \"message\"</p></li>\n<li><p>notify-send [\"title\"] \"message\" -t 500</p></li>\n</ul>\n</blockquote>\n\n<p>这里 -t 表示显示时间</p>\n\n<p>我在我的连接校园网的程序中也应用了这个。。。感觉比自己写好看多了</p>\n\n<p><a href=\"https://github.com/xiyoulaoyuanjia/blog/blob/master/%E5%85%B3%E4%BA%8E%E5%8C%97%E9%82%AE%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E7%A8%8B%E5%BA%8F.md\">这里</a></p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/e6dbd580e4b026fad88161a7e8328acd1898cd51/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6233643334342d2d3246784c6b7449506d5556516e364b74626a6242436c764c427832414d5a3374432d2d32426c7732632d2d32466871326256446f37476759647037664c4b774a4e67374b3277454f476650715039644856574c30577a756a446476455a\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/e6dbd580e4b026fad88161a7e8328acd1898cd51/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6233643334342d2d3246784c6b7449506d5556516e364b74626a6242436c764c427832414d5a3374432d2d32426c7732632d2d32466871326256446f37476759647037664c4b774a4e67374b3277454f476650715039644856574c30577a756a446476455a\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>xmessage</strong></p>\n\n<p>这个程序主要依赖 x libary 产生消息框的程序</p>\n\n<p>这个可以用来做一些shell层的选在框 </p>\n\n<pre><code>xmessage  \"Are you sure you want to shutdown? \" -buttons yes,no\necho $?\n</code></pre>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/8ce239a656fa815e7a0c0e3685d3a95b3b7550d3/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d62386134517a445545465570564e494837423332382d2d32464769534a636154486a462d2d3246766f7359726c6b7432706a552d2d324638445332724e732d2d3246612d2d3242514f4f6f6a707358624d736c65644963557a42666d746f6c2d2d32424a566f4879712d2d32422d2d3242533052\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/8ce239a656fa815e7a0c0e3685d3a95b3b7550d3/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d62386134517a445545465570564e494837423332382d2d32464769534a636154486a462d2d3246766f7359726c6b7432706a552d2d324638445332724e732d2d3246612d2d3242514f4f6f6a707358624d736c65644963557a42666d746f6c2d2d32424a566f4879712d2d32422d2d3242533052\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>或者</p>\n\n<pre><code>answer=$(xmessage  \"Are you sure you want to shutdown? \" -buttons yes,no -print)\necho $answer\n</code></pre>\n\n<p>常用的一些选项</p>\n\n<pre><code>-center – the message at center   \n-nearmouse – the message near mouse\n-timeout secs – will close after some seconds.\n</code></pre>\n\n<p>更多的可以 man xmessage 查看</p>\n\n<p><strong>Over SSH</strong></p>\n\n<pre><code>DISPLAY=:0; XAUTHORITY=~owner_of:0/.Xauthority; export DISPLAY XAUTHORITY\n</code></pre>\n\n<p>这个没有实践不多说....</p>','/xiyoulaoyuanjia/blog/blob/master/gnome%20popup%20Box%20message.md','db7ed05085a599669f05556d04375dab-b7bfee5e0de4674b90e4fc3505b34efce7419f63','<h1>\n<a name=\"gnome-popup-box-message-\" class=\"anchor\" href=\"#gnome-popup-box-message-\"><span class=\"mini-icon mini-icon-link\"></span></a>gnome popup Box message </h1>\n\n<p>之前写一些要用的脚本的时候.苦于没有找到方便的可视化消息通知方法\n之前的做法是是使用pyqt 写一些简单的message box 可以见<a href=\"https://github.com/xiyoulaoyuanjia/GetVdiskLink\">这里</a></p>\n\n<p>后来在<a href=\"http://smashingweb.info/send-messages-over-network-gnome-popup-box-message/\">这里</a>\n发现了gnome下的一些常用的Box message  方法。感觉用着很舒服。。这里推荐给大家</p>\n\n<p><strong>zenity:It will display a default ok box on the screen</strong></p>\n\n<blockquote>\n<ul>\n<li>display  GTK+ dialogs</li>\n<li> 输出 ”message here“ 信息</li>\n</ul>\n</blockquote>\n\n<pre><code>zenity --info --text \"message here\"\n</code></pre>'),(2,'flask 0.8 doc 读书笔记.md','<h1>\n<a name=\"flask-08-doc-\" class=\"anchor\" href=\"#flask-08-doc-\"><span class=\"mini-icon mini-icon-link\"></span></a>flask 0.8 doc 读书笔记</h1>\n\n<p><a href=\"https://dormousehole.readthedocs.org/en/latest/index.html\">原文</a></p>\n\n<hr><p><strong><a href=\"http://dormousehole.readthedocs.org/en/latest/quickstart.html\">快速上手</a></strong></p>\n\n<blockquote>\n<ul>\n<li><p>关于app = Flask(__name__)\n这句代码 这样子是为了区分一般模块调用与程序开始执行区别</p></li>\n<li><p>默认情况下只可以本地访问 如果需要网络上的其它人访问可以  app.run(host=\'0.0.0.0\')</p></li>\n<li><p>默认的开启调试的方法有 app.debug=true 或者 app.run(debug=true) 两种 </p></li>\n<li>\n<p>开启调试的好处有 </p>\n\n<blockquote>\n<ul>\n<li>错误会出更多的调试信息</li>\n<li>有文件修改时会自动重新启动</li>\n</ul>\n</blockquote>\n</li>\n<li><p>在url中添加变量</p></li>\n</ul>\n<blockquote>\n<ul>\n<li> 一般添加变量</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>@app.route(\'/user/username\')\ndef show_user_profile(username):\n    # show the user profile for that user\n    pass\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>添加转换器 这部分还用的不多奥</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>尾部有 斜杠  与没有的区别</li>\n</ul>\n</blockquote>\n\n<p>当尾部有\"/\"则当你访问/projects 会重定向到 \"/projects\"</p>\n\n<pre><code>@app.route(\'/projects/\')\ndef projects():\n    pass\n\n@app.route(\'/about\')\ndef about():\n    pass\n</code></pre>\n\n<blockquote>\n<ul>\n<li>url 构建</li>\n</ul>\n</blockquote>\n\n<p>这里需要理解两点</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>url_for 的用法 与我之前的理解有差距 不多说 上代码</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/f28f43ee10f321879d94dbc667ff0d805565f057/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d323361622d2d3242706852727363494e4c775274426a4c302d2d324630653362413369476b44496d752d2d32427a794a433365527867584244754e387441625062676f5a5056456a394c2d2d3242416e6751787163385a7553665375364369654238762d2d324257474248\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/f28f43ee10f321879d94dbc667ff0d805565f057/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d323361622d2d3242706852727363494e4c775274426a4c302d2d324630653362413369476b44496d752d2d32427a794a433365527867584244754e387441625062676f5a5056456a394c2d2d3242416e6751787163385a7553665375364369654238762d2d324257474248\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>注意 \ntest_request_context() 方法 的使用</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>url_for 的使用必须要上下文环境 test_request_context() 可以使其在shell环境下测试</p>\n\n<blockquote>\n<ul>\n<li>HTTP 的常见方法</li>\n</ul>\n</blockquote>\n\n<p>最常见的几种 get post put HEAD 方法</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li><p>默认只有 get请求方法有返回值了 这也就解释了为什么很多需要post请求返回的时候需要另外传入method 方法了..</p></li>\n<li><p>put 与post方法的不同</p></li>\n</ul>\n</blockquote>\n\n<ul>\n<li>静态文件</li>\n</ul>\n</blockquote>\n\n<p>使用静态文件 一般在页面中直接 url_for(\'static\', filename=\'style.css\')</p>\n\n<blockquote>\n<ul>\n<li>渲染模板 </li>\n</ul>\n</blockquote>\n\n<p>这部分有时间可以详细了解 细节   <a href=\"http://jinja.pocoo.org/2/\">Jinja2</a></p>\n\n<p>提供   render_template() 方法就可以渲染模板当然需要提供模板名称与参数值</p>\n\n<blockquote>\n<ul>\n<li>操作请求数据</li>\n</ul>\n</blockquote>\n\n<p>由全局  request 提供全局请求信息</p>\n\n<p>这里有一点需要讨论 request 是全局变量如果保证线程安全(即对于每一个客户端的请求保证每一个request的不一样呢?) 要回答这个问题不得不提_本地环境_</p>\n\n<blockquote>\n<ul>\n<li>本地环境 </li>\n</ul>\n<blockquote>\n<ul>\n<li>使用  test_request_context </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>from flask import request</p>\n\n<pre><code>with app.test_request_context(\'/hello\', method=\'POST\'):\n    # now you can do something with the request until the\n    # end of the with block, such as basic assertions:\n    assert request.path == \'/hello\'\n    assert request.method == \'POST\'\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>另一种是把wsgi整个环境传递给 </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>from flask import request\n\nwith app.request_context(environ):\n    assert request.method == \'POST\'\n</code></pre>\n\n<blockquote>\n<ul>\n<li>请求对象</li>\n</ul>\n</blockquote>\n\n<p>这里推荐完整的看API 中的关于request中的内容</p>\n\n<p>需要先引用requst  from flask import request</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>请求的方法  request.method </li>\n<li>使用请求中的form request.form[\'username\']</li>\n<li> 要操作 URL （如 ?key=value ）中提交的参数可以使用 args 属性: \nsearchword = request.args.get(\'key\', \'\')?</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>文件上传</li>\n</ul>\n</blockquote>\n\n<p>这里需要注意一点 需要在form 中添加 enctype=\"multipart/form-data\" 属性 </p>\n\n<blockquote>\n<ul>\n<li>Cookies</li>\n</ul>\n<blockquote>\n<ul>\n<li>获得 Cookies  request.cookies 对象 </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>username = request.cookies.get(\'username\')\n# 使用 cookies.get(key) 来代替 cookies[key] ，\n# 以避免当 cookie 不存在时引发 KeyError 。\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>使用  set_cookie 方法 设置cookies</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>from flask import make_response\n\n@app.route(\'/\')\ndef index():\n    resp = make_response(render_template(...))\n    resp.set_cookie(\'username\', \'the username\')\n    return resp\n</code></pre>\n\n<blockquote>\n<ul>\n<li>重定向与错误</li>\n</ul>\n<blockquote>\n<ul>\n<li><p>重定向 使用  redirect() 函数 可以</p></li>\n<li><p>abort(401) 函数可以结束并返回401 错误代码</p></li>\n<li><p>对于错误页面的处理例如定制404 出错页面可以使用 使用 errorhandler() 装饰器可以定制出错页面</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>例如 :</p>\n\n<pre><code>from flask import render_template\n\n@app.errorhandler(404)\ndef page_not_found(error):\n    return render_template(\'page_not_found.html\'), 404\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>上面代码最后的404,表示错误代码</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>关于响应</li>\n</ul>\n</blockquote>\n\n<p>flask 必须返回一个response 的响应对象,当然如果你返回的不是,flask 会为你做剩下的工作的</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>如果你返回的是response 的响应对象,flask 直接返回</li>\n<li><p>如果你返回的是字符串,flask会把字符串当成http body 默认为你添加 200的状态吗与 text/html MIME  的头信息</p></li>\n<li><p>如果你返回的是一个元祖,那么flask 会把这个元祖作为参数传递给响应构造器返回响应对象</p></li>\n<li><p>如果不是上面的3中 flask 会假定响应是一个有效的wsgi 应用.并把构造响应对象</p></li>\n<li><p>想操作响应对象的结构可以使用   make_response() 包裹返回表达式</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>@app.errorhandler(404)\ndef not_found(error):\n    resp = make_response(render_template(\'error.html\'), 404)\n    resp.headers[\'X-Something\'] = \'A value\'\n    return resp\n</code></pre>\n\n<blockquote>\n<ul>\n<li>会话 </li>\n</ul>\n</blockquote>\n\n<p>session对象</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>session 是为了在多次请求之前保存信息</li>\n<li><p>一般而言 session 信息保存在 服务器端. cookies信息保存在客户端 但是session 需要借助 cookies 机制(需要保存状态信息)  session 与客户端通信是加密的 cookies 则没有</p></li>\n<li><p>使用session 时需要先设计密钥</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>设置密钥，复杂一点：\napp.secret_key = \'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT\'\n</code></pre>\n\n<p>一般可以使用 如下方法设置密钥</p>\n\n<pre><code> import os\n os.urandom(24)\n\'\\xfd{H\\xe5\\x95\\xf9\\xe3\\x96.5\\xd1\\x01O!\\xd5\\xa2\\xa0\\x9fR\"\\xa1\\xa8\'\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>如果在flask 端自己写html 一般需要  escape() 来转义的</li>\n</ul>\n</blockquote>\n\n<ul>\n<li><p>消息闪现  不知道是什么呢?</p></li>\n<li><p>日志</p></li>\n</ul>\n<blockquote>\n<ul>\n<li>flask 中集成了 logging 日志模块</li>\n<li>使用</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>app.logger.debug(\'A value for debugging\')\napp.logger.warning(\'A warning occurred (%d apples)\', 42)\napp.logger.error(\'An error occurred\')\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>集成wsgi 中间件</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p><strong><a href=\"http://dormousehole.readthedocs.org/en/latest/tutorial/index.html\">教程</a></strong></p>\n\n<blockquote>\n<ul>\n<li><p>flask 介绍</p></li>\n<li><p>创建文件夹</p></li>\n<li><p>数据库模式</p></li>\n</ul>\n</blockquote>\n\n<p>数据库 结构保存为 schema.sql</p>\n\n<pre><code>drop table if exists entries;\ncreate table entries (\n  id integer primary key autoincrement,\n  title string not null,\n  text string not null\n);\n</code></pre>\n\n<blockquote>\n<ul>\n<li>应用构建代码</li>\n</ul>\n</blockquote>\n\n<pre><code># create our little application :)\napp = Flask(__name__)\napp.config.from_object(__name__)\napp.config.from_envvar(\'FLASKR_SETTINGS\', silent=True)\n</code></pre>\n\n<p>from_object() 会查看给定的对象（如果该对象是一个字符串就会 直接导入它），\n搜索对象中所有变量名均为大字字母的变量</p>\n\n<p>from_envvar 是从一个配置文件中导入 FLASKR_SETTINGS 是配置文件名称</p>\n\n<blockquote>\n<ul>\n<li>创建数据库</li>\n</ul>\n<blockquote>\n<ul>\n<li>命令行方式</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>sqlite3 /tmp/flaskr.db  schema.sql\n</code></pre>\n\n<p>不太好 需要支持 sqlite3命令 我们可以考虑使用另一中方法</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>程序里创建</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>def init_db():\n    with closing(connect_db()) as db:\n        with app.open_resource(\'schema.sql\') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n</code></pre>\n\n<blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>with 语句的使用</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<p>使用方法</p>\n\n<pre><code>class controlled_execution:\n        def __enter__(self):\n            set things up\n            return thing\n        def __exit__(self, type, value, traceback):\n            tear things down\n\nwith controlled_execution() as thing:\n    some code\n</code></pre>\n\n<p>Now, when the “with” statement is executed, Python evaluates the expression, \ncalls the <strong>enter</strong> method on the resulting value (which is called a “context guard”)\n, and assigns whatever <strong>enter</strong> returns to the variable given by as. \nPython will then execute the code body, \nand no matter what happens in that code, call the guard object’s <strong>exit</strong> method.</p>\n\n<p>详细见<a href=\"http://effbot.org/zone/python-with-statement.htm\">这里</a></p>\n\n<blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>closing 的使用</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<p>as to</p>\n\n<pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef closing(thing):\n    try:\n        yield thing\n    finally:\n        thing.close()\n</code></pre>\n\n<p>详见<a href=\"http://docs.python.org/dev/library/contextlib.html#contextlib.closing\">这里</a></p>\n\n<blockquote>\n<ul>\n<li>请求数据库连接</li>\n</ul>\n</blockquote>\n\n<p>这里重要考虑3个装饰器 </p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li> before_request()</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>使用 before_request() 装饰的函数会在请求之前调用，且不传递 参数</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li> after_request() </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>使用 after_request() 装饰的函数会在请求之后调用，且 传递发送给客户端响应对象,所以\n<strong>出错就不会执行</strong>_</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>teardown_request()</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>函数在响应对象构建后被调用。它们不允许修改请求，并且它们的返回值被忽略</p>\n\n<blockquote>\n<ul>\n<li>视图函数</li>\n</ul>\n<blockquote>\n<ul>\n<li>显示条目</li>\n<li>增加一个条目</li>\n<li>登录与注销</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>模板</li>\n</ul>\n</blockquote>\n\n<p>flask 使用 Jinja2 模板 并且默认开启 自动转义  对于一些特殊字符不需要转义的可以\n使用  Markup 标记 或者 |safe 过滤器 </p>\n\n<blockquote>\n<ul>\n<li><p>添加样式</p></li>\n<li><p>测试应用</p></li>\n</ul>\n</blockquote>\n\n<hr><p><strong>template</strong>\n<strong>默认使用</strong></p>\n\n<blockquote>\n<ul>\n<li>使用 jinja2 模板 当然可以替换模板但是 flask默认还是会安装jinja2 的模板的</li>\n<li>默认情况下 jinja2 模板会处理 .html .htm .xml .xhtml</li>\n<li>过滤器\n* tojson()  默认会把对象 过滤为json格式</li>\n</ul>\n</blockquote>\n\n<p>javascript 中会很有用</p>\n\n<pre><code>script type=text/javascript\n    doSomethingWith({{ user.username|tojson|safe }});\n/script\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>safe  取消模板的转义</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>用法与上面相同 </p>\n\n<p><strong>控制模板转义的3种方法</strong></p>\n\n<blockquote>\n<ul>\n<li> 在python中 做一个  Markup 的html对象 这个没用过。</li>\n<li> 使用 |safe 过滤器</li>\n</ul>\n</blockquote>\n\n<pre><code>{{ myvariable|safe }}\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用 {% autoescape %} 代码块</li>\n</ul>\n</blockquote>\n\n<pre><code>{% autoescape false %}\n    pautoescaping is disabled here\n    p{{ will_not_be_escaped }}\n{% endautoescape %}\n</code></pre>\n\n<p><strong>Context Processors</strong></p>\n\n<p>python 定义</p>\n\n<pre><code>@app.context_processor\ndef utility_processor():\n    def format_price(amount, currency=u\'€\'):\n        return u\'{0:.2f}{1}.format(amount, currency)\n    return dict(format_price=format_price)\n</code></pre>\n\n<p>template 中使用</p>\n\n<pre><code>{{ format_price(0.33) }}\n</code></pre>\n\n<hr>','/xiyoulaoyuanjia/blog/blob/master/flask%200.8%20doc%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md','7d0eac3397b730d548fc351b08d1c733-7ec91ac8dad1a6fce229bbcd8324f73195fe0e07','<h1>\n<a name=\"flask-08-doc-\" class=\"anchor\" href=\"#flask-08-doc-\"><span class=\"mini-icon mini-icon-link\"></span></a>flask 0.8 doc 读书笔记</h1>\n\n<p><a href=\"https://dormousehole.readthedocs.org/en/latest/index.html\">原文</a></p>'),(3,'Django.md','<h1>\n<a name=\"django\" class=\"anchor\" href=\"#django\"><span class=\"mini-icon mini-icon-link\"></span></a>Django</h1>\n\n<p><strong>视图与url配置</strong></p>\n\n<p>一个视图就是一个python的函数,并且必须满足两个条件</p>\n\n<blockquote>\n<ul>\n<li><p>函数的第一个类型必须是HttpRequest</p></li>\n<li><p>它返回一个HttpResponse实例</p></li>\n</ul>\n</blockquote>\n\n<p><strong>urlconf</strong></p>\n\n<p>urlconf 就是 Django所支撑的网站的目录结构,它的本质就是url结构,以及与该url结构相映射的视图,我们就是以这种方式告诉Django,对于哪个url调用哪个Django视图</p>\n\n<blockquote>\n<p>当开始执行 </p>\n</blockquote>\n\n<pre><code>django-admin.py startproject\n</code></pre>\n\n<p>脚本会自动创建一份 urlconf(默认文件为 urls.py)</p>\n\n<blockquote>\n<p>默认的urls.py的内容为 (1, 3, 4, \'final\', 0)</p>\n</blockquote>\n\n<pre><code>from django.conf.urls.defaults import patterns, include, url\nfrom mysite.views import *\n# Uncomment the next two lines to enable the admin:\n# from django.contrib import admin\n# admin.autodiscover()\n\nurlpatterns = patterns(\'\',\n    # Examples:\n    # url(r\'^$\', \'mysite.views.home\', name=\'home\'),\n    # url(r\'^mysite/\', include(\'mysite.foo.urls\')),\n\n    # Uncomment the admin/doc line below to enable admin documentation:\n    # url(r\'^admin/doc/\', include(\'django.contrib.admindocs.urls\')),\n\n    # Uncomment the next line to enable the admin:\n    # url(r\'^admin/\', include(admin.site.urls)),\n)\n</code></pre>\n\n<p><em>note</em> python 的搜索路径</p>\n\n<pre><code>import sys\nprint sys.path\n[\'\', \'/usr/lib/python2.6/site-packages/setuptools-0.6c11-py2.6.egg\', \'/usr/lib/python2.6/site-packages/pexpect-2.4-py2.6.egg\', \'/usr/lib64/python26.zip\', \'/usr/lib64/python2.6\', \'/usr/lib64/python2.6/plat-linux2\', \'/usr/lib64/python2.6/lib-tk\', \'/usr/lib64/python2.6/lib-old\', \'/usr/lib64/python2.6/lib-dynload\', \'/usr/lib64/python2.6/site-packages\', \'/usr/lib64/python2.6/site-packages/PIL\', \'/usr/lib64/python2.6/site-packages/gst-0.10\', \'/usr/lib64/python2.6/site-packages/gtk-2.0\', \'/usr/lib64/python2.6/site-packages/webkit-1.0\', \'/usr/lib/python2.6/site-packages\', \'/usr/lib/python2.6/site-packages/setuptools-0.6c11-py2.6.egg-info\']\n\n注意第一个空字符串表示在当前路径下寻找\n</code></pre>\n\n<p><strong>URLpattern</strong></p>\n\n<blockquote>\n<p>任何在匹配URLpattern的请求之前需要去掉之前的\"/\" 字符.这意味着我们为/hello/写URL模式不用包含斜杠(/) 关于这点的好处此刻还不是很清楚 例如内嵌等后续补充</p>\n\n<p>关于尾部/ 的处理 默认地，任何不匹配或尾部没有斜杠(/)的申请URL，将被重定向至尾部包含斜杠的相同字眼的URL 注意这是受到setting中APPEND_SLASH项控制</p>\n</blockquote>\n\n<p><em>如果你让它一直运行也可以，开发服务器会自动监测代码改动并自动重新载入，所以不需要手工重启</em></p>\n\n<p><em>关于网站根目录:默认情况下输入<a href=\"http://127.0.0.1:8000/\">http://127.0.0.1:8000/</a> 将获得一个404 错误 因为Djingo默认不会把根目录当做特殊处理 ，需要特殊处理必须使用 URLpattern 匹配它,例如 (\'^$\', myhomepath)</em></p>\n\n<p><em>Django 处理请求过程</em> </p>\n\n<p><em>note</em> <code>关注settings.py 文件 这个文件包含了所有有关这个Django项目的配置信息,均大写： TEMPLATE_DIRS , DATABASE_NAME , 等. 最重要的设置时ROOT_URLCONF，它将作为URLconf告诉Django在这个站点中那些Python的模块将被用到</code></p>\n\n<p><em>Django的时区 在setting文件中 且默认为America/Chicago</em></p>\n\n<p><em>当然在urlconf中可以考虑正则捕获,捕获的值依次(从第二个参数开始第一个参数是httprequest的实例)传入视图</em></p>\n\n<p><strong>Django 模板</strong></p>\n\n<blockquote>\n<ul>\n<li><p>include 模板标签</p></li>\n<li><p>模板继承 大多数情况下 include 与 模板继承 可以互相使用 </p></li>\n<li><p>模板是一个文本,用于分离其表现方式,模板定义了占位符与规范文档该如何显示,模板通常用来产生html文档，当然也可以产生其它文档</p></li>\n<li><p>模板标签 通知模板系统完成某些工作的标签\n例如 if 标签 {% if ordered_warranty %}  for 标签 {% for item in item_list %} </p></li>\n<li><p>模板变量 例如 {{ person_name }}</p></li>\n<li><p>过滤器  例如 {{shipdate|date:”F j, Y” }}  将变量shipdate传递给date过滤器，同时指定参数”F j,Y”。date过滤器根据参数进行格式输出。 过滤器是用管道符(|)来调用的</p></li>\n<li><p>模板系统是一个Python库，你可以在任何地方使用它，而不仅仅是在Django视图中</p></li>\n</ul>\n</blockquote>\n\n<p><strong>在python中使用模板的方法</strong></p>\n\n<blockquote>\n<ul>\n<li>创建一个模板对象 包括使用字符串与文件的方式创建</li>\n<li>调用模板对象的render方法,并且传入一套变量context</li>\n</ul>\n</blockquote>\n\n<pre><code>from django import template\nt = template.Template(\'My name is {{ name }}.\')\nc = template.Context({\'name\': \'Adrian\'})\nprint t.render(c)\nMy name is Adrian.\nc = template.Context({\'name\': \'Fred\'})\nprint t.render(c)\nMy name is Fred.\n</code></pre>\n\n<p>分布介绍</p>\n\n<p><strong>创建模板对象</strong></p>\n\n<p>直接实例化模板对象</p>\n\n<p><strong>模板渲染</strong></p>\n\n<p>一旦你创建一个 Template 对象，你可以用 context 来传递数据给它。 一个context是一系列变量和它们值的集合。</p>\n\n<p>content 在django里面是Context 类 在Template模块里面 构造函数里面是一个可选的字典参数,在字典里面传入需要渲染的变量与值  调用 Template 对象 的 render() 方法并传递context来填充模板：</p>\n\n<p><strong>注意render方法返回一个unicode</strong></p>\n\n<p>使用template模板的基本步骤为：写模板，创建 Template 对象，创建 Context ， 调用 render() 方法。</p>\n\n<p><strong>同一个模板多个上下文</strong>\n一旦有了模板对象，就可以使用它创建多个上下文\n<strong>注意进行一次模板创建调用多次rendor的方法比较高效</strong></p>\n\n<p><strong><em>理念与局限</em></strong></p>\n\n<p><em>可以再djaogo中使用其它模板语言</em></p>\n\n<p><strong><em>在视图中使用模板</em></strong></p>\n\n<p><strong><em>模板加载</em></strong>\n<em>note Django采用模板自加载与模板目录</em></p>\n\n<blockquote>\n<p>模板加载目录 在 settings.py 文件中的TEMPLATE_DIRS 字段下配置需要注意当只有一个的时候不要忘了加末尾的逗号</p>\n\n<p>在视图中引入模块 使用此方法django.template.loader.get_template() 并且已文件名为参数 当使用子目录的时候 这种方式 t = get_template(\'dateapp/current_datetime.html\') 很好</p>\n\n<p>使用render_to_response 简化 编写 例如 return render_to_response(\'current_datetime.html\', {\'current_date\': now})  直接把模块 渲染 与返回 放到一个函数中完成  注意需要 from django.shortcuts import render_to_response 才可以</p>\n</blockquote>\n\n<hr><p><strong>模型</strong></p>\n\n<p><strong><em>Django的mvc模型</em></strong></p>\n\n<blockquote>\n<ul>\n<li>m 数据存储模式 由Django 数据库层处理</li>\n<li>v 主要由模板处理 </li>\n<li>c 根据用户urlconf 配置 也就是python函数</li>\n</ul>\n</blockquote>\n\n<p><strong><em>数据库配置</em></strong></p>\n\n<p>settings.py 中查找如下</p>\n\n<pre><code>DATABASES = {\n\'default\': {\n    \'ENGINE\': \'django.db.backends.sqlite3\', # Add \'postgresql_psycopg2\',     \'postgresql\', \'mysql\', \'sqlite3\' or \'oracle\'.\n    \'NAME\': \'/home/mydb\',                      # Or path to database file if using sqlite3.\n    \'USER\': \'\',                      # Not used with sqlite3.\n    \'PASSWORD\': \'\',                  # Not used with sqlite3.\n    \'HOST\': \'\',                      # Set to empty string for localhost. Not used with sqlite3.\n    \'PORT\': \'\',                      # Set to empty string for default. Not used with sqlite3.\n}\n</code></pre>\n\n<p>}</p>\n\n<p><em>note 注意： 个人比较喜欢 mysql 与 sqlite3</em></p>\n\n<p>测试数据库连接</p>\n\n<pre><code>from django.db import connection\ncursor = connection.cursor()\n</code></pre>\n\n<p><em>note 注意区分project于app的区别 这里讲一个是配置一个是代码或许有些道理</em></p>\n\n<hr><p>Django</p>\n\n<hr><p><strong>Django表单</strong></p>\n\n<p><strong><em>Request对象中获取数据</em></strong>\n在一个视图函数里面第一个参数一般是HttpRequest对象,当然我们可以从这个函数中获得我们感兴趣的东西.例如 用户与浏览器的信息等</p>\n\n<p><em>url相关的信息</em>_</p>\n\n<p>属性/方法    说明 举例\nrequest.path    除域名以外的请求路径，以正斜杠开头 \"/hello/\"</p>\n\n<p>request.get_host()  主机名（比如，通常所说的域名）   \"127.0.0.1:8000\" or \"<a href=\"http://www.example.com\">www.example.com</a>\"</p>\n\n<p>request.get_full_path() 请求路径，可能包含查询字符串  \"/hello/?print=true\"</p>\n\n<p>request.is_secure() 如果通过HTTPS访问，则此方法返回True， 否则返回False   True 或者 False</p>\n\n<p><em>与Request相关的一些其它信息</em></p>\n\n<p><em>请求头信息</em></p>\n\n<p>request.META 这个是python的dict数据格式 包括本次HTTP请求的Header信息 常见的如用户的ag(user-agent)信息</p>\n\n<p><em>note 这里需要当访问的信息不存在时会发生错误</em></p>\n\n<p><strong><em>关于提交的数据</em></strong></p>\n\n<p>HttpRequest对象还包括另外两个属性 request.GET 和 request.POST 注意它们两个都是类字典对象 </p>\n\n<p>_note 类字典对象 可以理解为包含比字典跟多的方法 例如可以使用 for key in request.GET 获取所有的键 这里要强调request.GET 与 request.POST 包含比字典更多的 方法</p>\n\n<p>从前台html获得表单提交(get)的方法</p>\n\n<pre><code> if \'q\' in request.GET:\n    message = \'You searched for: %r\' % request.GET[\'q\']\n</code></pre>\n\n<p>继承django的form类 </p>\n\n<p>名称 django.forms 类,目的是为每一个要处理的html的form表单创建一个Form类,最好的处理方式是单独创建一个文件</p>\n\n<p>Form 类可以认为做了 </p>\n\n<blockquote>\n<ul>\n<li>转化为html</li>\n<li>校验合理性</li>\n<li>清理数据 即将数据转换为python数据类型</li>\n</ul>\n</blockquote>\n\n<pre><code> f = ContactForm({\'subject\': \'Hello\', \'message\': \'\'})\n f.errors\n{\'message\': [u\'This field is required.\']}\n</code></pre>\n\n<p><strong><em>改变字段显示</em></strong></p>\n\n<p><strong><em>设置最大字段长度</em></strong></p>\n\n<p><strong><em>设置初始值</em></strong></p>\n\n<p><strong><em>自定义校验规则</em></strong></p>\n\n<p>例如反馈页面 字数要求 这里主要有两种方法 1. 自定义字段类型 2. 直接挂在form类 上</p>\n\n<p><em>Django的form系统自动寻找匹配的函数方法，该方法名称以clean_开头，并以字段名称结束。 如果有这样的方法，它将在校验时被调用.</em></p>\n\n<p>_注意自定义的校验规则一般在最后,当然这也是很合理的,省去了不少麻烦</p>\n\n<p><strong><em>指定标签</em></strong>\nhtml生成的表单的标签是按默认规则生成的 例如 用空格代替下划线，首字母大写 当然这也是可以自定义的\n    email = forms.EmailField(required=False, <strong>label=\'Your e-mail address\'</strong> )</p>\n\n<hr><p><strong>高级视图与url配置</strong></p>\n\n<p><strong><em>URLconf 技巧</em></strong></p>\n\n<p><strong><em>使用命名组</em></strong></p>\n\n<p><em>注意关键字参数与位置参数</em></p>\n\n<p>_可以混合使用关键字参数与位置参数</p>\n\n<p>python的正则表达式中使用,命名的正则表达式的语法是(?Ppattern) name 是组的模式 pattern是正则模式</p>\n\n<p>在django中的使用</p>\n\n<pre><code>    from django.conf.urls.defaults import *\n    from mysite import views\n\n    urlpatterns = patterns(\'\',\n        (r\'^articles/(?Pyear\\d{4})/$\', views.year_archive),\n        (r\'^articles/(?Pyear\\d{4})/(?Pmonth\\d{2})/$\', views.month_archive),\n    )\n</code></pre>\n\n<p>在这里 传到视图中的参数将不再是位置参数而是关键字参数并且名字是year</p>\n\n<p><strong><em>理解匹配/分组算法</em></strong></p>\n\n<p><strong><em>传递额外的参数到视图函数中</em></strong></p>\n\n<p>写法</p>\n\n<pre><code>urlpatterns = patterns(\'\',\n(r\'^foo/$\', views.foobar_view, {\'template_name\': \'template1.html\'}),\n(r\'^bar/$\', views.foobar_view, {\'template_name\': \'template2.html\'}),\n)\n</code></pre>\n\n<p>在这个例子中指定了     template_name 这个参数 并且确定了其值为template1.html</p>\n\n<p>__这种使用额外的URLconf参数的技术以最小的代价给你提供了向视图函数传递额外信息的一个好方法</p>\n\n<p><strong><em>伪造捕捉到的URLconf值</em></strong></p>\n\n<p>例子</p>\n\n<pre><code>urlpatterns = patterns(\'\',\n(r\'^mydata/birthday/$\', views.my_view, {\'month\': \'jan\', \'day\': \'06\'}),\n(r\'^mydata/(?Pmonth\\w{3})/(?Pday\\d\\d)/$\', views.my_view),\n)\n</code></pre>\n\n<p>上面这种用法很巧妙</p>\n\n<p><strong><em>创建一个通用视图</em></strong>  </p>\n\n<p><strong><em>提供视图配置选项</em></strong>  </p>\n\n<p><strong><em>了解捕捉值和额外参数之间的优先级 额外的选项</em></strong></p>\n\n<p><em>note:额外URLconf参数优先于捕捉值</em></p>\n\n<pre><code>urlpatterns = patterns(\'\',\n(r\'^mydata/(?Pid\\d+)/$\', views.my_view, {\'id\': 3}),\n)\n</code></pre>\n\n<p>任何 这种 /mydata/2/ 或者 /mydata/432432/ 都会捕获为id=3</p>\n\n<p><strong><em>使用缺省视图参数</em></strong></p>\n\n<p>给一个视图参数指定默认的值</p>\n\n<pre><code>urlpatterns = patterns(\'\',\n    (r\'^blog/$\', views.page),\n    (r\'^blog/page(?Pnum\\d+)/$\', views.page),\n)\n\n# views.py\n\ndef page(request, num=\'1\'):\n    # Output the appropriate page of blog entries, according to num.\n    # ...\n</code></pre>\n\n<p>可以使用上面的技术做到缺省默认参数的效果</p>\n\n<p><strong><em>从URL中捕获文本</em></strong></p>\n\n<p>_note:每个被捕获的参数都将作为python的字符串参数来传递,而不管其捕获的类型</p>\n\n<p><strong><em>URLconf搜索的东西</em></strong></p>\n\n<p>默认情况下的搜索为<a href=\"http://www.example.com/myapp/\">http://www.example.com/myapp/</a> 的请求 Django试着从myapp/ 开始匹配\n<a href=\"http://www.example.com/myapp/?page=3\">http://www.example.com/myapp/?page=3</a> 的请求中,Django同样会去匹配 myapp/</p>\n\n<p>所以对于不同的请求(POST,GET,HEAD),区分要在视图函数中区分</p>\n\n<pre><code>from django.http import Http404, HttpResponseRedirect\nfrom django.shortcuts import render_to_response\n\ndef method_splitter(request, GET=None, POST=None):\n    if request.method == \'GET\' and GET is not None:\n        return GET(request)\n    elif request.method == \'POST\' and POST is not None:\n        return POST(request)\n    raise Http404\n\ndef some_page_get(request):\n    assert request.method == \'GET\'\n    do_something_for_get()\n    return render_to_response(\'page.html\')\n\ndef some_page_post(request):\n    assert request.method == \'POST\'\n    do_something_for_post()\n    return HttpResponseRedirect(\'/someurl/\')\n\n# urls.py\n\nfrom django.conf.urls.defaults import *\nfrom mysite import views\n\nurlpatterns = patterns(\'\',\n    # ...\n    (r\'^somepage/$\', views.method_splitter, {\'GET\': views.some_page_get, \'POST\': views.some_page_post}),\n    # ...\n</code></pre>\n\n<p>上面处理方法还是十分优雅的</p>\n\n<p>当上面的GET 与 POST 参数较多的时候需要使用变量传参方法</p>\n\n<p>例如：\n    def method_splitter(request, *args, **kwargs):\n    get_view = kwargs.pop(\'GET\', None)\n    post_view = kwargs.pop(\'POST\', None)\n    if request.method == \'GET\' and get_view is not None:\n        return get_view(request, *args, **kwargs)\n    elif request.method == \'POST\' and post_view is not None:\n        return post_view(request, *args, **kwargs)\n    raise Http404   </p>\n\n<p>foo(1, 2, name=\'Adrian\', framework=\'Django\')\n其中args 取例如(1,2) kwargs 取 {\'framework\': \'Django\', \'name\': \'Adrian\'}</p>\n\n<p><strong><em>包装视图函数</em></strong></p>\n\n<p>这里举例如登陆认证 需要在每一个视图里面都进行验证</p>\n\n<p><strong>包含其他URLconf</strong></p>\n\n<p>语法：(r\'^weblog/\', include(\'mysite.blog.urls\')),</p>\n\n<p>遇到include 将匹配剩下的字符发往include包含的Urlconf 继续匹配\n此处体现了模块化方式的一种</p>\n\n<p><strong><em>额外的URLconf如何和include()协同工作</em></strong></p>\n\n<p>这里需要说明一点 被捕获的参数一样，将要被传递到include里面的每一样而不管其需不需要。</p>\n\n<hr><p><strong>模板高级进阶</strong></p>\n\n<p><em>note: 可以单独讲模板系统应用于其它程序</em></p>\n\n<p><strong><em>模板标签回顾</em></strong></p>\n\n<p>模板是纯文本文件,主要包括两部分 模板标签与变量</p>\n\n<p>{{ first_name }}--变量   模板标签--{% if is_logged_in %}</p>\n\n<p><strong>模板渲染:通过content获取值来替换模板中的变量***并执行模板标签***</strong></p>\n\n<p><strong><em>RequestContext和Context处理器</em></strong></p>\n\n<p>context 是django.template.Context 的实例,RequestContext是context的子类。RequestContext 在模板中默认加入了一些变量,</p>\n\n<p>例如:RequestContext(request, {\'message\': \'I am the second view.\'},processors=[custom_proc]) 默认processors参数</p>\n\n<p>Django 提供对全局context的支持 默认情况下 在 TEMPLATE_CONTEXT_PROCESSORS 中设置 例如</p>\n\n<pre><code>TEMPLATE_CONTEXT_PROCESSORS = (\n    \'django.core.context_processors.auth\',\n    \'django.core.context_processors.debug\',\n    \'django.core.context_processors.i18n\',\n    \'django.core.context_processors.media\',\n)\n</code></pre>\n\n<p>几个Django默认启动的简单的Django处理器</p>\n\n<p><em>django.core.context_processors.auth</em></p>\n\n<p>包含这个TEMPLATE_CONTEXT_PROCESSORS处理器, 每个RequestContext包含的变量为</p>\n\n<blockquote>\n<ul>\n<li><p>user django.contrib.auth.models.User 实例 描述了当前登陆用户</p></li>\n<li><p>messages 当前登陆用户的消息列表</p></li>\n<li><p>perms 是django.core.context_processors.PermWrapper 的实例 用来描述用户的权限问题</p></li>\n</ul>\n</blockquote>\n\n<p><em>django.core.context_processors.debug</em> </p>\n\n<p>把调试信息发到模板层,包含的变量</p>\n\n<blockquote>\n<ul>\n<li><p>debug：设置的DEBUG(settings.py文件中)值,可以再模板中测试是否在测试条件下</p></li>\n<li><p>sql_queries {‘sql’:...,\'time\':...} 记录请求期间每一个sql查询与其所用时间</p></li>\n</ul>\n</blockquote>\n\n<p>_生效的两个条件 1.DEBUG 为true 2.ip必须在INTERNAL_IPS 范围内</p>\n\n<p>_从生效的条件可以看出如果</p>\n\n<p><em>django.core.context_processors.request</em></p>\n\n<p>这个处理器启动，每个RequestContext将包含request对象,也就是包含当前HttpRequest对象,当然这个默认是不启动的</p>\n\n<p>例如在一个request中调用ip的例子</p>\n\n<blockquote>\n<ul>\n<li>{{ request.REMOTE_ADDR }}</li>\n</ul>\n</blockquote>\n\n<p><strong><em>html自动转义</em></strong>  </p>\n\n<p>_注意从模板 生成 html时,存在风险 例如  Hello, {{ name }}. 当用户名变量为 alert(#39;hello#39;) 时 模板渲染结果为 Hello, alert(#39;hello#39;) 当然在某些条件下这是很危险的</p>\n\n<p>要避免上面的问题可以有两种方法</p>\n\n<blockquote>\n<ul>\n<li><p>可以把每一个不信任的变量都让escape过滤器处理一遍,但这样增加了开发者的问题</p></li>\n<li><p>Django的自动html转意</p></li>\n</ul>\n</blockquote>\n\n<p>5个特殊字符的转换</p>\n\n<blockquote>\n<ul>\n<li> 被转意为  </li>\n<li> 被转意为  \n*　\' (single quote) 被转意为 \' </li>\n<li>\" (double quote) 被转意为 \" </li>\n<li> 被转意为 </li>\n</ul>\n</blockquote>\n\n<p>上面默认是开启的，_ 关闭他们默认的方法_</p>\n\n<p><em>对于变量</em></p>\n\n<blockquote>\n<ul>\n<li>This will be escaped: {{ data }}</li>\n<li>This will not be escaped: {{ data|safe }}</li>\n</ul>\n</blockquote>\n\n<p><em>对于模板块</em></p>\n\n<p>对于模板的自动转换,可以用标签autoescape 来包装，并通过开关 on 或者off来控制</p>\n\n<pre><code>Auto-escaping is on by default. Hello {{ name }}\n\n{% autoescape off %}\nThis will not be auto-escaped: {{ data }}.\n\nNor this: {{ other_data }}\n{% autoescape on %}\n    Auto-escaping applies again: {{ name }}\n{% endautoescape %}\n{% endautoescape %}\n</code></pre>\n\n<p><strong><em>模块加载</em></strong></p>\n\n<p>常见两种方式</p>\n\n<blockquote>\n<ul>\n<li>django.template.loader.get_template(template_name) </li>\n<li>django.template.loader.select_template(template_name_list) </li>\n</ul>\n</blockquote>\n\n<p>分别以列表与路径名方式加载,在内部上面使用模板加载器来完成任务。一些模板加载器默认是禁止的需要手动开启,通过编辑TEMPLATE_LOADERS 来开启它们</p>\n\n<blockquote>\n<ul>\n<li>django.template.loaders.filesystem.load_template_source  这个加载器根据 TEMPLATE_DIRS 的设置从文件系统加载模板 并且默认是可用的</li>\n<li>django.template.loaders.app_directories.load_template_source 这个加载器从INSTALLED_APPS 每个模板应用中查找templates 子目录,Django在那里寻找模板</li>\n</ul>\n</blockquote>\n\n<p>例如如果INSTALLED_APPS 包含 (\'myproject.polls\',\'myproject.music\'),那么get_template(\'foo.html\')那如下顺序查找</p>\n\n<blockquote>\n<ul>\n<li>/path/to/myproject/polls/templates/foo.html</li>\n<li>/path/to/myproject/music/templates/foo.html</li>\n</ul>\n</blockquote>\n\n<p><strong>扩展模板系统</strong> </p>\n\n<p>注意模板系统还有很多内容</p>\n\n<p>_ps. 未完成待续</p>\n\n<h1></h1>\n\n<h1>\n<a name=\"-1\" class=\"anchor\" href=\"#-1\"><span class=\"mini-icon mini-icon-link\"></span></a><strong>模板高级进阶</strong>\n</h1>\n\n<p><strong>通用视图</strong></p>\n\n<p>django 内建通用视图可以实现如下功能</p>\n\n<blockquote>\n<ul>\n<li>　完成简单的任务,例如重定向到一个页面及渲染一个指定的模板</li>\n<li>　显示对象或列表的相信信息\n*　 基于日期年月的归档</li>\n</ul>\n</blockquote>\n\n<p><em>使用通用视图</em></p>\n\n<pre><code>from django.conf.urls.defaults import *\nfrom django.views.generic.simple import direct_to_template\n\nurlpatterns = patterns(\'\',\n    (r\'^about/$\', direct_to_template, {\n        \'template\': \'about.html\'\n    })\n)\n</code></pre>\n\n<p>当然我们还可以重用通用视图</p>\n\n<pre><code>from django.conf.urls.defaults import *\nfrom django.views.generic.simple import direct_to_template\n**from mysite.books.views import about_pages**\n\nurlpatterns = patterns(\'\',\n    (r\'^about/$\', direct_to_template, {\n        \'template\': \'about.html\'\n    }),\n    (r\'^about/(\\w+)/$\', about_pages),\n)\n</code></pre>\n\n<p>对于我们的about_pages 视图函数中使用direct_to_template视图(当然也就是函数)</p>\n\n<pre><code>from django.http import Http404\nfrom django.template import TemplateDoesNotExist\nfrom django.views.generic.simple import direct_to_template\n\ndef about_pages(request, page):\n    try:\n        return direct_to_template(request, template=\"about/%s.html\" % page)\n    except TemplateDoesNotExist:\n        raise Http404()\n</code></pre>\n\n<p><em>对象的通用视图</em></p>\n\n<p>_note:django通用视图最有用的地方是呈现数据库中的数据</p>\n\n<p>例如需要显示所有的出版商(查询数据库中出版商Publisher 表的所有元素)</p>\n\n<p>对于数据库出版商这个model对应的 python代码为</p>\n\n<pre><code>class Publisher(models.Model):\n    name = models.CharField(max_length=30)\n    address = models.CharField(max_length=50)\n    city = models.CharField(max_length=60)\n    state_province = models.CharField(max_length=30)\n    country = models.CharField(max_length=50)\n    website = models.URLField()\n\n    def __unicode__(self):\n        return self.name\n\n    class Meta:\n        ordering = [\'name\']\n</code></pre>\n\n<p>对应的url写法为</p>\n\n<pre><code>from django.conf.urls.defaults import *\nfrom django.views.generic import list_detail\nfrom mysite.books.models import Publisher\n\npublisher_info = {\n    \'queryset\': Publisher.objects.all(),\n    \'template_name\': \'publisher_list_page.html\',\n}\n\nurlpatterns = patterns(\'\',\n    (r\'^publishers/$\', list_detail.object_list, publisher_info)\n)\n</code></pre>\n\n<p><em>主要在这里面当publisher_info 中没有template_name 时默认请求的模板名称为books/publisher_list.html  方法为app名称/publisher_info.html</em></p>\n\n<p>publisher_list_page.html 模板为</p>\n\n<pre><code>{% extends \"base.html\" %}\n\n{% block content %}\n    h2Publishers/h2\n    ul\n        {% for publisher in object_list %}\n            li{{ publisher.name }}/li\n        {% endfor %}\n    /ul\n{% endblock %}\n</code></pre>\n\n<p>注意这里的base.html 模板</p>\n\n<p><strong><em>扩展通用视图</em></strong></p>\n\n<p>_note publisher_info  把template_object_name 加入会是一个好的方法</p>\n\n<pre><code>publisher_info = {\n    \'queryset\': Publisher.objects.all(),\n    \'template_name\': \'publisher_list_page.html\',\n    \'template_object_name\': \'publisher\',\n}\n</code></pre>\n\n<p><strong><em>添加额外的Context</em></strong></p>\n\n<p>所有的通用视图都有一个额外的可选参数 extra_context </p>\n\n<pre><code>publisher_info = {\n    \'queryset\': Publisher.objects.all(),\n    \'template_object_name\': \'publisher\',\n    \'extra_context\': {\'book_list\': Book.objects.all()}\n}\n</code></pre>\n\n<p><strong><em>显示对象的子集</em></strong></p>\n\n<p>例如需要显示的对象按日期排序</p>\n\n<p>大多数通用视图有一个queryset参数，这个参数告诉视图要显示对象的集合</p>\n\n<pre><code>book_info = {\n    \'queryset\': Book.objects.order_by(\'-publication_date\'),\n}\n</code></pre>\n\n<p><strong><em>用函数包装来处理复杂的数据过滤</em></strong></p>\n\n<p><strong><em>处理额外工作</em></strong></p>\n\n<h1></h1>\n\n<p><strong>部署Django</strong></p>\n\n<p><strong><em>关闭Debug模式</em></strong></p>\n\n<p>默认情况下使用django-admin.py startproject 创建项目时 settings.py 文件的DEBUG设置为true 注意在这种模式下Django的行为</p>\n\n<blockquote>\n<ul>\n<li><p>所有的数据库查询都被保存在内存中 以 django.db.connection.queries 的形式 所有这种行为是很消耗内存的</p></li>\n<li><p>404错误页面的不同，当然调试错误与发布错误是不同的</p></li>\n<li><p>应用程序没有捕获任何错误信息</p></li>\n</ul>\n</blockquote>\n\n<p><strong><em>关闭模板Debug模式</em></strong></p>\n\n<p>TEMPLATE_DEBUGFalse 设置为True,这是为了在上面的django错误页显示更多的模板信息</p>\n\n<p>_note:听说在最近 版本已经将TEMPLATE_DEBUGFalse=DEBUG 恩，这确实是个不错的想法</p>\n\n<p><strong><em>实现一个模板404错误页</em></strong></p>\n\n<p>_如果Debug设置为\"TRUE\"，显示自带的404调试错误页。如果Debug设置为\"FALSE\",则Django会在模板根目录中显示\"404.html\"模板</p>\n\n<p><strong><em>实现一个500模板</em></strong></p>\n\n<p>_此处描述与上面相同</p>\n\n<p><strong><em>设置错误警告</em></strong></p>\n\n<p>当发生错误时发送信息(邮件)到开发团队,当然需要两个条件</p>\n\n<blockquote>\n<ul>\n<li>改变你的ADMINS设置用来引入你的E-mail地址</li>\n<li>确保服务器配置了发送电子邮件</li>\n</ul>\n</blockquote>\n\n<p><strong><em>设置连接中断警报</em></strong></p>\n\n<p><strong><em>使用针对产品的不同的设置</em></strong></p>\n\n<p>这里考虑可以使用3种方法</p>\n\n<blockquote>\n<ul>\n<li><p>设置成两个全面的，彼此独立的配置文件</p></li>\n<li><p>设置一个基本的配置文件，另一个从前一个导入其变量的设置</p></li>\n</ul>\n</blockquote>\n\n<pre><code># settings_production.py    \nfrom settings import *\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用一个单独的配置文件，此配置文件包含一个Python的逻辑判断根据上下文环境改变设置。</li>\n</ul>\n</blockquote>\n\n<pre><code>import socket\n\nif socket.gethostname() == \'my-laptop\':\n    DEBUG = TEMPLATE_DEBUG = True\nelse:\n    DEBUG = TEMPLATE_DEBUG = False\n</code></pre>\n\n<p><strong><em>重命名settings.py</em></strong></p>\n\n<p>通过修改manage.py 文件，将 import settings 语句改为导入你自己的模块.DJANGO_SETTINGS_MODULE指向你的配置文件，在你的配置文件中指向你的ROOT_URLCONF,在ROOT_URLCONF中指向了你的视图以及其他的部分。</p>\n\n<p><strong><em>apache与mod_python 部署Django</em></strong></p>\n\n<p>mod_python 是一个再apahce中运行python的组件</p>\n\n<p>_基本配置</p>\n\n<p><strong><em>一种替代方案： mod_wsgi模块</em></strong></p>\n\n<p><strong><em>使用FastCGI部署Django应用</em></strong></p>\n\n<p><strong><em>FastCGI 简介</em></strong></p>\n\n<p>和mod_python一样FastCGI也是贮存在内存中的cgi,但是与其它相比省掉了每一次启动的开销问题,与mod_python 不同的是它不是作为apache的一部分作为同一进程启动的，\n而是有自己的独立进程.</p>\n\n<p>_note：当然这样的好处是不用作为免去了加载apache其它特性的东西,它仅仅把Python和Django等必备的东东弄到内存中</p>\n\n<p>_note：当然apache与FastCGI通信当然有两种方法1.Unix domain socket方法。2.TCP socket通信</p>\n\n<p>开始服务器项目,进入项目目录下</p>\n\n<pre><code>./manage.py runfcgi [options]\n</code></pre>\n\n<p>在TCP端口上运行一个线程服务器</p>\n\n<pre><code>./manage.py runfcgi method=threaded host=127.0.0.1 port=3033\n</code></pre>\n\n<p>在Unix socket上运行prefork服务器：</p>\n\n<pre><code>/manage.py runfcgi method=prefork socket=/home/user/mysite.sock pidfile=django.pid\n</code></pre>\n\n<p><strong><em>在Apache中以FastCGI的方式使用Django</em></strong></p>\n\n<p>_note:需要配置httpd.conf来让Apache和Django FastCGI互相通信，当然apache需要mod_fastcgi模块的支持</p>\n\n<blockquote>\n<ul>\n<li>使用 FastCGIExternalServer 指明FastCGI的位置</li>\n</ul>\n</blockquote>\n\n<p>例如</p>\n\n<pre><code># Connect to FastCGI via a socket/named pipe:\nFastCGIExternalServer /home/user/public_html/mysite.fcgi -socket /home/user/mysite.sock\n\n# Connect to FastCGI via a TCP host/port:\nFastCGIExternalServer /home/user/public_html/mysite.fcgi -host 127.0.0.1:3033\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用 mod_rewrite 为FastCGI指定合适的URL。</li>\n</ul>\n</blockquote>\n\n<p>这个需要告诉server那些url需要转换给Django来处理 使用mod_rewrite 模块，并将这些URL重定向到 mysite.fcgi</p>\n\n<pre><code>VirtualHost 12.34.56.78\n  ServerName example.com\n  DocumentRoot /home/user/public_html\n  Alias /media /home/user/python/django/contrib/admin/media\n  RewriteEngine On\n  RewriteRule ^/(media.*)$ /$1 [QSA,L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteRule ^/(.*)$ /mysite.fcgi/$1 [QSA,L]\n/VirtualHost\n</code></pre>\n\n<p><strong><em>FastCGI 和 lighttpd</em></strong></p>\n\n<p>_note 是一个轻量级的Web服务器，通常被用来提供静态页面的访问。 它天生支持FastCGI，因此除非你的站点需要一些Apache特有的特性，否则，lighttpd对于静态和动态页面来说都是理想的选择。</p>\n\n<p><strong><em>在一个lighttpd进程中运行多个Django站点</em></strong></p>\n\n<p>未完待续</p>\n\n<h1></h1>\n\n<p><strong>输出非html内容</strong></p>\n\n<p>当然web发布数据不仅仅是 html,还有RSS、PDF、图片等</p>\n\n<p>Django内建的工具生成非HTML内容</p>\n\n<blockquote>\n<ul>\n<li><p>RSS聚合内容</p></li>\n<li><p>站点地图</p></li>\n</ul>\n</blockquote>\n\n<p><strong><em>基础:视图和MIME类型</em></strong></p>\n\n<p>一个Django视图函数必须要含有</p>\n\n<blockquote>\n<ul>\n<li><p>接收一个httprequest作为第一个参数</p></li>\n<li><p>返回一个httpresponse 实例</p></li>\n</ul>\n</blockquote>\n\n<p>从一个视图返回一个非html最主要的是构造一个httpresponse实例，需要指定mimetype参数。通过改变mimetype参数浏览器可以知道访问的资源类型</p>\n\n<pre><code>from django.http import HttpResponse\n\ndef my_image(request):\n    image_data = open(\"/path/to/my/image.png\", \"rb\").read()\n    return HttpResponse(image_data, mimetype=\"image/png\")\n</code></pre>\n\n<p><strong><em>生成 CSV 文件</em></strong></p>\n\n<p>因为 csv 模块操作的是类似文件的对象，所以可以使用 HttpResponse 替换：</p>\n\n<pre><code>import csv\nfrom django.http import HttpResponse\n\n# Number of unruly passengers each year 1995 - 2005. In a real application\n# this would likely come from a database or some other back-end data store.\nUNRULY_PASSENGERS = [146,184,235,200,226,251,299,273,281,304,203]\n\ndef unruly_passengers_csv(request):\n    # Create the HttpResponse object with the appropriate CSV header.\n    response = HttpResponse(mimetype=\'text/csv\')\n    response[\'Content-Disposition\'] = \'attachment; filename=unruly.csv\'\n\n    # Create the CSV writer using the HttpResponse as the \"file.\"\n    writer = csv.writer(response)\n    writer.writerow([\'Year\', \'Unruly Airline Passengers\'])\n    for (year, num) in zip(range(1995, 2006), UNRULY_PASSENGERS):\n        writer.writerow([year, num])\n\n    return response\n</code></pre>\n\n<p>_注意附加的 Content-Disposition 头部,这个会指示浏览器在保存文件的时候询问保存的位置</p>\n\n<p><strong><em>生成 PDF 文件</em></strong></p>\n\n<p>_编写视图</p>\n\n<pre><code>from reportlab.pdfgen import canvas\nfrom django.http import HttpResponse\n\ndef hello_pdf(request):\n    # Create the HttpResponse object with the appropriate PDF headers.\n    response = HttpResponse(mimetype=\'application/pdf\')\n    response[\'Content-Disposition\'] = \'attachment; filename=hello.pdf\'\n\n    # Create the PDF object, using the response object as its \"file.\"\n    p = canvas.Canvas(response)\n\n    # Draw things on the PDF. Here\'s where the PDF generation happens.\n    # See the ReportLab documentation for the full list of functionality.\n    p.drawString(100, 100, \"Hello world.\")\n\n    # Close the PDF object cleanly, and we\'re done.\n    p.showPage()\n    p.save()\n    return response\n</code></pre>\n\n<p><strong><em>内容聚合器应用框架</em></strong></p>\n\n<p><strong>未完</strong></p>\n\n<hr><p><strong>会话、用户和注册</strong></p>\n\n<p>_note:http 被设计成\"无状态的\"，即每一次的链接都是处于相同的空间中的,我们无法从请求的任何方便来判断是不是同一个人的连接</p>\n\n<p><strong><em>cookies</em></strong></p>\n\n<p>cookies 是浏览器为 Web 服务器存储的一小段信息,每次浏览器从服务器请求页面时，它都向服务器回送之前收到的cookies</p>\n\n<p><strong><em>存取Cookies</em></strong></p>\n\n<p>在处理持久化,一般都会使用session或者user框架，这里主要了解底层如何读写cookies</p>\n\n<p>读取cookies 很简单,每一个httprequest都有一个cookies对象,其操作类似字典形式</p>\n\n<pre><code>request.COOKIES[\"favorite_color\"]\n</code></pre>\n\n<p>写cookies可以使用 HttpResponse对象的 set_cookie()方法.</p>\n\n<pre><code>response.set_cookie(\"favorite_color\",request.GET[\"favorite_color\"])\n</code></pre>\n\n<p>一般还可以设置的 max_age、expires、path、domain 等</p>\n\n<p><strong><em>好坏参半的Cookies</em></strong></p>\n\n<blockquote>\n<ul>\n<li>cookies的存取是自愿的,可以选择控制是否存储</li>\n<li>cookies 是不可靠的</li>\n<li>http是以明文发送的,也就是说cookies是不安全的</li>\n</ul>\n</blockquote>\n\n<p><strong><em>django的session框架</em></strong></p>\n\n<p>session通过一个中间件和一个模型来实现的</p>\n\n<p><em>打开 Sessions功能</em></p>\n\n<blockquote>\n<ul>\n<li>MIDDLEWARE_CLASSES 包含django.contrib.sessions.middleware.SessionMiddleware</li>\n<li>INSTALLED_APPS含有django.contrib.sessions</li>\n</ul>\n</blockquote>\n\n<p><em>在视图中使用session</em></p>\n\n<p>SessionMiddleware 激活后,每一个httprequest都含有一个session属性,当然这是一个字典型的对象</p>\n\n<pre><code># Set a session value:\nrequest.session[\"fav_color\"] = \"blue\"\n\n# Get a session value -- this could be called in a different view,\n# or many requests later (or both):\nfav_color = request.session[\"fav_color\"]\n</code></pre>\n\n<p>使用Django sessions的简单规则：</p>\n\n<blockquote>\n<ul>\n<li>session 字典中以下划线开头的key值是Django内部保留的key值</li>\n<li>不要用一个新的对象来替换掉request.session,也不要存取其属性。</li>\n</ul>\n</blockquote>\n\n<pre><code>request.session = some_other_object # Don\'t do this!\nrequest.session.foo = \'bar\' # Don\'t do this!\n</code></pre>\n\n<p><strong><em>设置测试Cookies</em></strong></p>\n\n<p>并不是所有的浏览器都支持cookies,所以需要测试</p>\n\n<p>Django中的验证方法为:</p>\n\n<pre><code>request.session.test_cookie_worked()\n</code></pre>\n\n<p>检查cookie是否可以正常工作后，你得自己用 delete_test_cookie() 来清除它</p>\n\n<p><strong><em>在视图外使用session</em></strong></p>\n\n<pre><code> from django.contrib.sessions.models import Session\n s = Session.objects.get(pk=\'2b1189a188b44ad18c35e113ac6ceead\')\n s.expire_date\ndatetime.datetime(2005, 8, 20, 13, 35, 12)\n</code></pre>\n\n<p>_note: 现在版本的django的session里面 包含的字段session_key, session_data, expire_date</p>\n\n<p>可以使用get_decoded() 来读取实际的session数据</p>\n\n<pre><code> s.session_data\n\'KGRwMQpTJ19hdXRoX3VzZXJfaWQnCnAyCkkxCnMuMTExY2ZjODI2Yj...\'\n s.get_decoded()\n{\'user_id\': 42}\n</code></pre>\n\n<p><strong><em>何时保存Session</em></strong></p>\n\n<p>默认情况下,django只在session发生变化的时候才会存入数据库.比如说，字典赋值或删除。\n当然可以使用SESSION_SAVE_EVERY_REQUEST 这一字段来改变这一默认行为。即当每一次请求都保存数据库</p>\n\n<p><strong><em>浏览器关闭即失效会话 vs 持久会话</em></strong></p>\n\n<p>cookie中的expires设置过期时间,默认情况下如果没有设置过期时间当用户关闭浏览器的时候，cookie就自动过期了。你可以改变 SESSION_EXPIRE_AT_BROWSER_CLOSE 的设置来控制session框架的这一行为。\n如果SESSION_EXPIRE_AT_BROWSER_CLOSE 为false，则会话的cookies将会保持SESSION_COOKIE_AGE 秒的时间</p>\n\n<p><strong><em>其他的Session设置</em></strong></p>\n\n<p>这个可以参考源代码</p>\n\n<p><strong><em>用户与Authentication</em></strong></p>\n\n<p>通过session我们可以再多次浏览请求中保持数据,当然最常用的还是用session还处理用户登录的问题了。</p>\n\n<p>django中的认证与授权系统 auth/auth 一般步骤如下</p>\n\n<blockquote>\n<ul>\n<li>验证 (认证) 用户是否是他所宣称的用户(一般通过查询数据库验证其用户名和密码)</li>\n<li>验证用户是否拥有执行某种操作的 授权 (通常会通过检查一个权限表来确认)</li>\n</ul>\n</blockquote>\n\n<p>django 认证与授权系统包含如下</p>\n\n<blockquote>\n<ul>\n<li>用户 : 在网站注册的人</li>\n<li>权限 : 用于标识用户是否可以执行某种操作的二进制(yes/no)标志</li>\n<li>组 :一种可以将标记和权限应用于多个用户的常用方法<br>\n</li>\n<li>Messages向用户显示队列式的系统消息的常用方法<br>\n</li>\n</ul>\n</blockquote>\n\n<p><strong><em>打开认证支持</em></strong>     </p>\n\n<p>session 也是一个Django的应用,放在 django.contrib 中</p>\n\n<blockquote>\n<ul>\n<li>需要确保用户使用cookies</li>\n<li>django.contrib.auth 需要在INSTALLED_APPS 中,并且 manage.py syncdb以创建对应的数据库表</li>\n<li>\'django.contrib.auth.middleware.AuthenticationMiddleware\' 确认在SessionMiddleware </li>\n</ul>\n</blockquote>\n\n<p>安装好之后就可以在view视图函数中使用user了，视图中存取users，主要用 request.user ,这个表示已经登录的用户.对于没有登录的用户默认为AnonymousUser对象</p>\n\n<p>你可以很容易地通过 is_authenticated() 方法来判断一个用户是否已经登录了：</p>\n\n<pre><code>if request.user.is_authenticated():\n# Do something for authenticated users.\nelse:\n# Do something for anonymous users.\n</code></pre>\n\n<p><strong><em>使用User对象</em></strong></p>\n\n<p>User 实例一般从 request.user 它包含许多属性与方法,这里需要注意AnonymousUser对象并不是都包含这些方法.</p>\n\n<p>表 14-3. User 对象属性</p>\n\n<p>属性  描述</p>\n\n<p>username    必需的，不能多于30个字符。 仅用字母数字式字符（字母、数字和下划线）。</p>\n\n<p>first_name  可选; 少于等于30字符。</p>\n\n<p>last_name   可选; 少于等于30字符。</p>\n\n<p>email   可选。 邮件地址。</p>\n\n<p>password    必需的。 密码的哈希值（Django不储存原始密码）。 See the Passwords section for more about this value.</p>\n\n<p>is_staff    布尔值。 用户是否拥有网站的管理权限。</p>\n\n<p>is_active   布尔值. 设置该账户是否可以登录。 把该标志位置为False而不是直接删除账户。</p>\n\n<p>is_superuser    布尔值 标识用户是否拥有所有权限，无需显式地权限分配定义。</p>\n\n<p>last_login  用户上次登录的时间日期。 它被默认设置为当前的日期/时间。</p>\n\n<p>date_joined 账号被创建的日期时间 当账号被创建时，它被默认设置为当前的日期/时间。</p>\n\n<p><strong><em>登录和退出</em></strong></p>\n\n<p>django提供内置的视图用于处理登录和退出。当然可以手工登录与退出.\ndjango提供两个函数用来执行验证用户身份与登录 authenticate() 和 login() 函数</p>\n\n<pre><code> from django.contrib import auth\n user = auth.authenticate(username=\'john\', password=\'secret\')\n if user is not None:\n...     print \"Correct!\"\n... else:\n...     print \"Invalid password.\"\n\nfrom django.contrib import auth\n\ndef login_view(request):\n    username = request.POST.get(\'username\', \'\')\n    password = request.POST.get(\'password\', \'\')\n    user = auth.authenticate(username=username, password=password)\n    if user is not None and user.is_active:\n        # Correct password, and the user is marked \"active\"\n        auth.login(request, user)\n        # Redirect to a success page.\n        return HttpResponseRedirect(\"/account/loggedin/\")\n    else:\n        # Show an error page\n        return HttpResponseRedirect(\"/account/invalid/\")\n</code></pre>\n\n<p>上面演示了如何使用authenticate() 和 login() 函数</p>\n\n<p>注销一个用户</p>\n\n<pre><code>from django.contrib import auth\ndef logout_view(request):\n    auth.logout(request)\n    # Redirect to a success page.\n    return HttpResponseRedirect(\"/account/loggedout/\")\n</code></pre>\n\n<p>*注意:这里需要注意即使用户没有登录logout也不会返回异常</p>\n\n<p>当然在实际中一般不需要用户自己写登录/登出的函数. 使用其的第一步是写urlConf函数</p>\n\n<pre><code>from django.contrib.auth.views import login, logout\n\nurlpatterns = patterns(\'\',\n    # existing patterns here...\n    (r\'^accounts/login/$\',  login),\n    (r\'^accounts/logout/$\', logout),\n)\n</code></pre>\n\n<p>/accounts/login/ 和 /accounts/logout/ 是Django提供的视图的默认URL。</p>\n\n<p>login 视图渲染 registragiton/login.html 模板</p>\n\n<p>logout视图有一些不同。 默认情况下它渲染 registration/logged_out.html 模板</p>\n\n<p><strong><em>限制已登录用户的访问</em></strong></p>\n\n<p>控制用户登录后访问的站点的某些部分</p>\n\n<p><strong><em>对通过测试的用户限制访问</em></strong></p>\n\n<p>限制访问可以基于某种权限，某些检查或者为login视图提供不同的位置</p>\n\n<p>一种方法是直接在用户的request.user 上检查 例如</p>\n\n<pre><code>def vote(request):\n    if request.user.is_authenticated() and request.user.has_perm(\'polls.can_vote\')):\n        # vote here\n    else:\n        return HttpResponse(\"You can\'t vote in this poll.\")\n\n\ndef user_can_vote(user):\n    return user.is_authenticated() and user.has_perm(\"polls.can_vote\")\n\n@user_passes_test(user_can_vote, login_url=\"/login/\")\ndef vote(request):\n    # Code here can assume a logged-in user with the correct permission.\n\nfrom django.contrib.auth.decorators import permission_required\n\n@permission_required(\'polls.can_vote\', login_url=\"/login/\")\ndef vote(request):\n    # ...\n</code></pre>\n\n<p><strong><em>限制通用视图的访问</em></strong></p>\n\n<p><strong><em>管理 Users, Permissions 和 Groups</em></strong></p>\n\n<p>一般通过admin就可以了.这里的粒度比较细</p>\n\n<p><em>创建用户</em></p>\n\n<pre><code> from django.contrib.auth.models import User\n user = User.objects.create_user(username=\'john\',\n...                                 email=\'jlennon@beatles.com\',\n...                                 password=\'glass onion\')\n\n user.is_staff = True\n user.save()\n</code></pre>\n\n<p><em>修改密码</em></p>\n\n<p>使用 set_password() 来修改密码：当然这一般是不直接编辑的,因为里面存储的是加入salt的hash值.</p>\n\n<pre><code> user = User.objects.get(username=\'john\')\n user.set_password(\'goo goo goo joob\')\n user.save()\n</code></pre>\n\n<p><em>处理注册</em></p>\n\n<p><strong><em>在模板中使用认证数据</em></strong>\n<strong><em>权限、组和消息</em></strong></p>\n\n<p><em>权限</em></p>\n\n<p><em>组</em></p>\n\n<p><em>消息</em></p>\n\n<p>当然未完待续</p>\n\n<hr>','/xiyoulaoyuanjia/blog/blob/master/Django.md','fdd130a353af80dd5f61783b9593fb73-943a7196dd28bc3881a38ec4be95c40c3dfa796c','<h1>\n<a name=\"django\" class=\"anchor\" href=\"#django\"><span class=\"mini-icon mini-icon-link\"></span></a>Django</h1>\n\n<p><strong>视图与url配置</strong></p>\n\n<p>一个视图就是一个python的函数,并且必须满足两个条件</p>\n\n<blockquote>\n<ul>\n<li><p>函数的第一个类型必须是HttpRequest</p></li>\n<li><p>它返回一个HttpResponse实例</p></li>\n</ul>\n</blockquote>\n\n<p><strong>urlconf</strong></p>\n\n<p>urlconf 就是 Django所支撑的网站的目录结构,它的本质就是url结构,以及与该url结构相映射的视图,我们就是以这种方式告诉Django,对于哪个url调用哪个Django视图</p>\n\n<blockquote>\n<p>当开始执行 </p>\n</blockquote>\n\n<pre><code>django-admin.py startproject\n</code></pre>\n\n<p>脚本会自动创建一份 urlconf(默认文件为 urls.py)</p>\n\n<blockquote>\n<p>默认的urls.py的内容为 (1, 3, 4, \'final\', 0)</p>\n</blockquote>\n\n<pre><code>from django.conf.urls.defaults import patterns, include, url\nfrom mysite.views import *\n# Uncomment the next two lines to enable the admin:\n# from django.contrib import admin\n# admin.autodiscover()\n\nurlpatterns = patterns(\'\',\n    # Examples:\n    # url(r\'^$\', \'mysite.views.home\', name=\'home\'),\n    # url(r\'^mysite/\', include(\'mysite.foo.urls\')),\n\n    # Uncomment the admin/doc line below to enable admin documentation:\n    # url(r\'^admin/doc/\', include(\'django.contrib.admindocs.urls\')),\n\n    # Uncomment the next line to enable the admin:\n    # url(r\'^admin/\', include(admin.site.urls)),\n)\n</code></pre>\n\n<p><em>note</em> python 的搜索路径</p>\n\n<pre><code>import sys\nprint sys.path\n[\'\', \'/usr/lib/python2.6/site-packages/setuptools-0.6c11-py2.6.egg\', \'/usr/lib/python2.6/site-packages/pexpect-2.4-py2.6.egg\', \'/usr/lib64/python26.zip\', \'/usr/lib64/python2.6\', \'/usr/lib64/python2.6/plat-linux2\', \'/usr/lib64/python2.6/lib-tk\', \'/usr/lib64/python2.6/lib-old\', \'/usr/lib64/python2.6/lib-dynload\', \'/usr/lib64/python2.6/site-packages\', \'/usr/lib64/python2.6/site-packages/PIL\', \'/usr/lib64/python2.6/site-packages/gst-0.10\', \'/usr/lib64/python2.6/site-packages/gtk-2.0\', \'/usr/lib64/python2.6/site-packages/webkit-1.0\', \'/usr/lib/python2.6/site-packages\', \'/usr/lib/python2.6/site-packages/setuptools-0.6c11-py2.6.egg-info\']\n\n注意第一个空字符串表示在当前路径下寻找\n</code></pre>\n\n<p><strong>URLpattern</strong></p>\n\n<blockquote>\n<p>任何在匹配URLpattern的请求之前需要去掉之前的\"/\" 字符.这意味着我们为/hello/写URL模式不用包含斜杠(/) 关于这点的好处此刻还不是很清楚 例如内嵌等后续补充</p>\n\n<p>关于尾部/ 的处理 默认地，任何不匹配或尾部没有斜杠(/)的申请URL，将被重定向至尾部包含斜杠的相同字眼的URL 注意这是受到setting中APPEND_SLASH项控制</p>\n</blockquote>\n\n<p><em>如果你让它一直运行也可以，开发服务器会自动监测代码改动并自动重新载入，所以不需要手工重启</em></p>\n\n<p><em>关于网站根目录:默认情况下输入<a href=\"http://127.0.0.1:8000/\">http://127.0.0.1:8000/</a> 将获得一个404 错误 因为Djingo默认不会把根目录当做特殊处理 ，需要特殊处理必须使用 URLpattern 匹配它,例如 (\'^$\', myhomepath)</em></p>\n\n<p><em>Django 处理请求过程</em> </p>\n\n<p><em>note</em> <code>关注settings.py 文件 这个文件包含了所有有关这个Django项目的配置信息,均大写： TEMPLATE_DIRS , DATABASE_NAME , 等. 最重要的设置时ROOT_URLCONF，它将作为URLconf告诉Django在这个站点中那些Python的模块将被用到</code></p>\n\n<p><em>Django的时区 在setting文件中 且默认为America/Chicago</em></p>\n\n<p><em>当然在urlconf中可以考虑正则捕获,捕获的值依次(从第二个参数开始第一个参数是httprequest的实例)传入视图</em></p>\n\n<p><strong>Django 模板</strong></p>\n\n<blockquote>\n<ul>\n<li><p>include 模板标签</p></li>\n<li><p>模板继承 大多数情况下 include 与 模板继承 可以互相使用 </p></li>\n<li><p>模板是一个文本,用于分离其表现方式,模板定义了占位符与规范文档该如何显示,模板通常用来产生html文档，当然也可以产生其它文档</p></li>\n<li><p>模板标签 通知模板系统完成某些工作的标签\n例如 if 标签 {% if ordered_warranty %}  for 标签 {% for item in item_list %} </p></li>\n<li><p>模板变量 例如 {{ person_name }}</p></li>\n<li><p>过滤器  例如 {{shipdate|date:”F j, Y” }}  将变量shipdate传递给date过滤器，同时指定参数”F j,Y”。date过滤器根据参数进行格式输出。 过滤器是用管道符(|)来调用的</p></li>\n<li><p>模板系统是一个Python库，你可以在任何地方使用它，而不仅仅是在Django视图中</p></li>\n</ul>\n</blockquote>\n\n<p><strong>在python中使用模板的方法</strong></p>\n\n<blockquote>\n<ul>\n<li>创建一个模板对象 包括使用字符串与文件的方式创建</li>\n<li>调用模板对象的render方法,并且传入一套变量context</li>\n</ul>\n</blockquote>\n\n<pre><code>from django import template\nt = template.Template(\'My name is {{ name }}.\')\nc = template.Context({\'name\': \'Adrian\'})\nprint t.render(c)\nMy name is Adrian.\nc = template.Context({\'name\': \'Fred\'})\nprint t.render(c)\nMy name is Fred.\n</code></pre>\n\n<p>分布介绍</p>\n\n<p><strong>创建模板对象</strong></p>\n\n<p>直接实例化模板对象</p>\n\n<p><strong>模板渲染</strong></p>\n\n<p>一旦你创建一个 Template 对象，你可以用 context 来传递数据给它。 一个context是一系列变量和它们值的集合。</p>\n\n<p>content 在django里面是Context 类 在Template模块里面 构造函数里面是一个可选的字典参数,在字典里面传入需要渲染的变量与值  调用 Template 对象 的 render() 方法并传递context来填充模板：</p>\n\n<p><strong>注意render方法返回一个unicode</strong></p>\n\n<p>使用template模板的基本步骤为：写模板，创建 Template 对象，创建 Context ， 调用 render() 方法。</p>\n\n<p><strong>同一个模板多个上下文</strong>\n一旦有了模板对象，就可以使用它创建多个上下文\n<strong>注意进行一次模板创建调用多次rendor的方法比较高效</strong></p>\n\n<p><strong><em>理念与局限</em></strong></p>\n\n<p><em>可以再djaogo中使用其它模板语言</em></p>\n\n<p><strong><em>在视图中使用模板</em></strong></p>\n\n<p><strong><em>模板加载</em></strong>\n<em>note Django采用模板自加载与模板目录</em></p>\n\n<blockquote>\n<p>模板加载目录 在 settings.py 文件中的TEMPLATE_DIRS 字段下配置需要注意当只有一个的时候不要忘了加末尾的逗号</p>\n\n<p>在视图中引入模块 使用此方法django.template.loader.get_template() 并且已文件名为参数 当使用子目录的时候 这种方式 t = get_template(\'dateapp/current_datetime.html\') 很好</p>\n\n<p>使用render_to_response 简化 编写 例如 return render_to_response(\'current_datetime.html\', {\'current_date\': now})  直接把模块 渲染 与返回 放到一个函数中完成  注意需要 from django.shortcuts import render_to_response 才可以</p>\n</blockquote>'),(4,'开始写自己的vim 函数.md','<h1>\n<a name=\"vim-\" class=\"anchor\" href=\"#vim-\"><span class=\"mini-icon mini-icon-link\"></span></a>开始写自己的vim 函数</h1>\n\n<blockquote>\n<ul>\n<li>函数名必须以大写字母开头</li>\n</ul>\n</blockquote>\n\n<pre><code>hex2dec is 非法\nHex2dec is 合法的\n</code></pre>\n\n<p>c语言与bash 允许 这样子的函数名。</p>\n\n<blockquote>\n<ul>\n<li>如何引用函数参数</li>\n</ul>\n</blockquote>\n\n<pre><code>fu! Hex2dec(var1, var2)\n  let str=a:var1\n  let str2=a:var2\n</code></pre>\n\n<p>参数名前必须有一个\"a\"的，在函数里面不允许 更改参数例如像 let a:var1=1 这样的的使用\n是不允许的。</p>\n\n<p>当然在c语言里面 是不需要\"a\"前缀的。。参数一般来说也是可以更改的。。</p>\n\n<p>更多可以查看 :help a:1</p>\n\n<blockquote>\n<ul>\n<li>如何在函数中使用可变参数</li>\n</ul>\n</blockquote>\n\n<pre><code>fu! Hex2dec(fixedparam, ...)\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>a0 表示 .... 中的参数个数</li>\n<li>a1 代表 .... 中的第一个参数 依次类推</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>例如:</p>\n\n<pre><code>:call Hex2dec(\"asdf\", 4,5,6)\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>a:0 = 3, a:1 = 4, a:2 = 5, a:3 = 6.</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>更多可以参考  :help a:0   :help a:000</p>\n\n<blockquote>\n<ul>\n<li>如何从一个可变参数函数中调用另一个可变参数函数</li>\n</ul>\n</blockquote>\n\n<pre><code>function! Hex2DecWrapper(...)\n  let params = [\'asdf\'] + a:000\n  :call call (function(\'Hex2Dec\'), params)\nendfunction\n</code></pre>\n\n<blockquote>\n<ul>\n<li>vim 的库(vim-library)在哪里？</li>\n</ul>\n</blockquote>\n\n<p>vim 具有它自己的函数库。。可以通过:help functions 来查看</p>\n\n<blockquote>\n<ul>\n<li>如何使用 ++ 或者 += 运算符</li>\n</ul>\n<blockquote>\n<ul>\n<li>+= 在 vim 7.0 版本之后才存在</li>\n<li>++ 不存在</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>如何使用变量</li>\n</ul>\n</blockquote>\n\n<pre><code>let var1=value\nlet var2=var1\n</code></pre>\n\n<p>当然在c语言中 let 是不允许使用的。</p>\n\n<p>更多可以查看 :help :let 或者 :help expression</p>\n\n<blockquote>\n<ul>\n<li>在一个函数中可以使用任意的外部命令吗？</li>\n</ul>\n</blockquote>\n\n<p>可以 每一行都可以是 一个外部命令</p>\n\n<blockquote>\n<ul>\n<li>函数可以调用它自己吗？(递归使用)</li>\n</ul>\n</blockquote>\n\n<p>可以 但是要小心无穷递归</p>\n\n<blockquote>\n<ul>\n<li>函数怎么调用另一个函数</li>\n</ul>\n</blockquote>\n\n<p>可以向c语言一样的使用</p>\n\n<blockquote>\n<ul>\n<li>需要编译函数吗？</li>\n</ul>\n</blockquote>\n\n<p>你不能并且也不需要这样子做。\n在vim 中你可以向下面那样子引入你的vim脚本</p>\n\n<pre><code>:so filename_containing_script\n</code></pre>\n\n<p>之后你就可以使用该脚本的函数了</p>\n\n<p>当然 如何你想这些也可以在你的vimrc 文件中来做</p>\n\n<blockquote>\n<ul>\n<li>vim 有浮点数 整形 等数据类型吗？</li>\n</ul>\n</blockquote>\n\n<p>vim 向perl 一样 它的类型是由它所在的上下文决定的。。</p>\n\n<pre><code>let a=1\nlet a=a.\"asdf\"\necho a    (displays \'1asdf\')\nlet a=1\nlet a=a+2\necho a    (displays \'3\')\n</code></pre>\n\n<blockquote>\n<ul>\n<li>每一条语句都需要\";\" 结尾吗？</li>\n</ul>\n</blockquote>\n\n<p>不,从不需要那样子做.当然如果你需要 在一行中使用多条语句可以考虑 \"|\" 符号\n“;” 在 c 语言中是必须的，在bash中是可选的。</p>\n\n<blockquote>\n<ul>\n<li>参考</li>\n</ul>\n<blockquote>\n<ul>\n<li>:help :function</li>\n<li>:help a:1</li>\n<li>:help expression</li>\n<li><p>:help functions</p></li>\n<li><p>:help script</p></li>\n<li><p>:help autoload to write Vim library plugins</p></li>\n<li><p>:help script-local to hide functions in scripts</p></li>\n<li><p>Vim WikiBook about scripting</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p><a href=\"http://vim.wikia.com/wiki/Write_your_own_Vim_function#How_to_reference_function_parameters\">原文</a></p>','/xiyoulaoyuanjia/blog/blob/master/%E5%BC%80%E5%A7%8B%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84vim%20%E5%87%BD%E6%95%B0.md','1b69627e282407c6678daf9850789bd1-3fd0d7b3b9aff41c4e151801a6dac223d3d8a197','<h1>\n<a name=\"vim-\" class=\"anchor\" href=\"#vim-\"><span class=\"mini-icon mini-icon-link\"></span></a>开始写自己的vim 函数</h1>\n\n<blockquote>\n<ul>\n<li>函数名必须以大写字母开头</li>\n</ul>\n</blockquote>\n\n<pre><code>hex2dec is 非法\nHex2dec is 合法的\n</code></pre>\n\n<p>c语言与bash 允许 这样子的函数名。</p>\n\n<blockquote>\n<ul>\n<li>如何引用函数参数</li>\n</ul>\n</blockquote>\n\n<pre><code>fu! Hex2dec(var1, var2)\n  let str=a:var1\n  let str2=a:var2\n</code></pre>\n\n<p>参数名前必须有一个\"a\"的，在函数里面不允许 更改参数例如像 let a:var1=1 这样的的使用\n是不允许的。</p>\n\n<p>当然在c语言里面 是不需要\"a\"前缀的。。参数一般来说也是可以更改的。。</p>\n\n<p>更多可以查看 :help a:1</p>\n\n<blockquote>\n<ul>\n<li>如何在函数中使用可变参数</li>\n</ul>\n</blockquote>\n\n<pre><code>fu! Hex2dec(fixedparam, ...)\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>a0 表示 .... 中的参数个数</li>\n<li>a1 代表 .... 中的第一个参数 依次类推</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>例如:</p>\n\n<pre><code>:call Hex2dec(\"asdf\", 4,5,6)\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>a:0 = 3, a:1 = 4, a:2 = 5, a:3 = 6.</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>更多可以参考  :help a:0   :help a:000</p>\n\n<blockquote>\n<ul>\n<li>如何从一个可变参数函数中调用另一个可变参数函数</li>\n</ul>\n</blockquote>\n\n<pre><code>function! Hex2DecWrapper(...)\n  let params = [\'asdf\'] + a:000\n  :call call (function(\'Hex2Dec\'), params)\nendfunction\n</code></pre>\n\n<blockquote>\n<ul>\n<li>vim 的库(vim-library)在哪里？</li>\n</ul>\n</blockquote>\n\n<p>vim 具有它自己的函数库。。可以通过:help functions 来查看</p>\n\n<blockquote>\n<ul>\n<li>如何使用 ++ 或者 += 运算符</li>\n</ul>\n<blockquote>\n<ul>\n<li>+= 在 vim 7.0 版本之后才存在</li>\n<li>++ 不存在</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>如何使用变量</li>\n</ul>\n</blockquote>\n\n<pre><code>let var1=value\nlet var2=var1\n</code></pre>\n\n<p>当然在c语言中 let 是不允许使用的。</p>\n\n<p>更多可以查看 :help :let 或者 :help expression</p>\n\n<blockquote>\n<ul>\n<li>在一个函数中可以使用任意的外部命令吗？</li>\n</ul>\n</blockquote>\n\n<p>可以 每一行都可以是 一个外部命令</p>\n\n<blockquote>\n<ul>\n<li>函数可以调用它自己吗？(递归使用)</li>\n</ul>\n</blockquote>\n\n<p>可以 但是要小心无穷递归</p>\n\n<blockquote>\n<ul>\n<li>函数怎么调用另一个函数</li>\n</ul>\n</blockquote>\n\n<p>可以向c语言一样的使用</p>\n\n<blockquote>\n<ul>\n<li>需要编译函数吗？</li>\n</ul>\n</blockquote>\n\n<p>你不能并且也不需要这样子做。\n在vim 中你可以向下面那样子引入你的vim脚本</p>\n\n<pre><code>:so filename_containing_script\n</code></pre>\n\n<p>之后你就可以使用该脚本的函数了</p>\n\n<p>当然 如何你想这些也可以在你的vimrc 文件中来做</p>\n\n<blockquote>\n<ul>\n<li>vim 有浮点数 整形 等数据类型吗？</li>\n</ul>\n</blockquote>\n\n<p>vim 向perl 一样 它的类型是由它所在的上下文决定的。。</p>\n\n<pre><code>let a=1\nlet a=a.\"asdf\"\necho a    (displays \'1asdf\')\nlet a=1\nlet a=a+2\necho a    (displays \'3\')\n</code></pre>\n\n<blockquote>\n<ul>\n<li>每一条语句都需要\";\" 结尾吗？</li>\n</ul>\n</blockquote>\n\n<p>不,从不需要那样子做.当然如果你需要 在一行中使用多条语句可以考虑 \"|\" 符号\n“;” 在 c 语言中是必须的，在bash中是可选的。</p>\n\n<blockquote>\n<ul>\n<li>参考</li>\n</ul>\n<blockquote>\n<ul>\n<li>:help :function</li>\n<li>:help a:1</li>\n<li>:help expression</li>\n<li><p>:help functions</p></li>\n<li><p>:help script</p></li>\n<li><p>:help autoload to write Vim library plugins</p></li>\n<li><p>:help script-local to hide functions in scripts</p></li>\n<li><p>Vim WikiBook about scripting</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p><a href=\"http://vim.wikia.com/wiki/Write_your_own_Vim_function#How_to_reference_function_parameters\">原文</a></p>'),(5,'dns 安全.md','<p>2012 春节期间 github 受到dns污染的干扰 访问github的网站 都会返回一个59.24.3.173的ip地址。</p>\n\n<p><strong>dns 污染</strong></p>\n\n<p>一般而言 dns使用udp协议。在dns服务器查询期间发现你访问的是基于某一个网站则在，然后造一个假的回应包并在真正的包返回之前给你就行了，然后假的包里面只要把实际的 IP\n改成另外一个 IP 就行。</p>\n\n<p>运行dig @8.8.8.8 twitter.com 并使用wireshark 抓包 如图可得</p>\n\n<p><a href=\"https://mail-attachment.googleusercontent.com/attachment/u/0/?ui=2&ik=429fe34bc2&view=att&th=13c5d593b7a78fb7&attid=0.1&disp=inline&realattid=f_hc7nowqc0&safe=1&zw&saduie=AG9B_P_yefQZTkL1e79QyVqUxjWo&sadet=1361360033407&sads=3q3QrYvd1A7D8v-RpoXm83rH7qs\" target=\"_blank\"><img src=\"https://mail-attachment.googleusercontent.com/attachment/u/0/?ui=2&ik=429fe34bc2&view=att&th=13c5d593b7a78fb7&attid=0.1&disp=inline&realattid=f_hc7nowqc0&safe=1&zw&saduie=AG9B_P_yefQZTkL1e79QyVqUxjWo&sadet=1361360033407&sads=3q3QrYvd1A7D8v-RpoXm83rH7qs\" alt=\"dns污染\" style=\"max-width:100%;\"></a></p>\n\n<p>一般而言有一个伪造ip列表\n8.7.198.45\n37.61.54.158\n46.82.174.68\n59.24.3.173\n78.16.49.15\n93.46.8.89\n159.106.121.75\n203.98.7.65\n243.185.187.39\n或者没有answer。</p>\n\n<p><strong>几种解决方案</strong></p>\n\n<p><em>把本机的53端口的包重定向要vps的非知名端口，然后在vps的非知名端口上开一个dns server,然后解析完了扔回来</em></p>\n\n<p><em>通过dnscrypt 解决dns 污染...</em></p>\n\n<p><em>drop 掉上面的那些列表的方案</em></p>\n\n<p><em>dnsmasq 方案</em></p>\n\n<p>_note dnsmasq 一般用作三种用途 1.提供dns服务 2. 优先使用本地自定义的dns 3.提供dhcp服务 关于其它使用参考 <a href=\"http://www.aslibra.com/blog/post/dnsmasq.php\">http://www.aslibra.com/blog/post/dnsmasq.php</a> 文档</p>','/xiyoulaoyuanjia/blog/blob/master/dns%20%E5%AE%89%E5%85%A8.md','ffe652367eb2765838241e31d80f35ad-ea36209c5963e8b20df3cdf7e0081d9e9616a5be','<p>2012 春节期间 github 受到dns污染的干扰 访问github的网站 都会返回一个59.24.3.173的ip地址。</p>\n\n<p><strong>dns 污染</strong></p>\n\n<p>一般而言 dns使用udp协议。在dns服务器查询期间发现你访问的是基于某一个网站则在，然后造一个假的回应包并在真正的包返回之前给你就行了，然后假的包里面只要把实际的 IP\n改成另外一个 IP 就行。</p>\n\n<p>运行dig @8.8.8.8 twitter.com 并使用wireshark 抓包 如图可得</p>'),(6,'sso.md','<p><strong><a href=\"http://fm.qq.com%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%88%B0%E6%9C%AC%E5%9C%B0qq%E7%99%BB%E9%99%86%E7%9A%84%EF%BC%9F\">http://fm.qq.com如何检测到本地qq登陆的？</a></strong></p>\n\n<p>这个问题分为两个部分</p>\n\n<blockquote>\n<ul>\n<li><p>如何检测到本地客户端qq登陆的?</p></li>\n<li><p>如何检测到webqq登陆的?</p></li>\n</ul>\n</blockquote>\n\n<p>这个问题也就是***sso***技术Single Sign On</p>\n\n<p>sso技术是在多个应用系统中用户只需一次登录就可以登陆多个信任的系统中。</p>\n\n<p>webqq是共用一个sso的domain做session验证啦。。。都有一个qq.com域名含有相同的session所有的cookie都有一个范围，叫domain，如“.sun.com”。这个范围规定了只有在访问相同domain的时候，浏览器才会将此cookie带上</p>\n\n<p>所以对于webqq检测比较简单。。</p>\n\n<hr>','/xiyoulaoyuanjia/blog/blob/master/sso.md','44e70900c9335af5ac013fd0bd4b3b54-539ba99447c39afec409f3ec32e97c696174cc78','<p><strong><a href=\"http://fm.qq.com%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%88%B0%E6%9C%AC%E5%9C%B0qq%E7%99%BB%E9%99%86%E7%9A%84%EF%BC%9F\">http://fm.qq.com如何检测到本地qq登陆的？</a></strong></p>\n\n<p>这个问题分为两个部分</p>\n\n<blockquote>\n<ul>\n<li><p>如何检测到本地客户端qq登陆的?</p></li>\n<li><p>如何检测到webqq登陆的?</p></li>\n</ul>\n</blockquote>\n\n<p>这个问题也就是***sso***技术Single Sign On</p>\n\n<p>sso技术是在多个应用系统中用户只需一次登录就可以登陆多个信任的系统中。</p>\n\n<p>webqq是共用一个sso的domain做session验证啦。。。都有一个qq.com域名含有相同的session所有的cookie都有一个范围，叫domain，如“.sun.com”。这个范围规定了只有在访问相同domain的时候，浏览器才会将此cookie带上</p>\n\n<p>所以对于webqq检测比较简单。。</p>'),(7,'python 中 sqlite3 的使用.md','<h1>\n<a name=\"python--sqlite3-\" class=\"anchor\" href=\"#python--sqlite3-\"><span class=\"mini-icon mini-icon-link\"></span></a>python 中 sqlite3 的使用</h1>\n\n<p><strong>优点使用方便但是功能相比较其它大型数据库有所差距</strong></p>\n\n<p><strong>python的数据库模块有统一的接口，操作基本有统一的模式</strong> </p>\n\n<p>假设数据库模块名称为 sqlite3</p>\n\n<blockquote>\n<ul>\n<li>创建数据库连接 sqlite3.connect,返回连接对象为com</li>\n<li>如果不需要返回结果可以直接com.execute 查询。有时需要使用 com.commit 提交事务</li>\n<li><p>如果需要查询返回结果。则需要使用游标 com.cursor 创建游标对象 cur.. 通过cur.execute 查询数据库\n用 cur.fetchall/cur.fetchone/cur.fetchmany 获取查询结果. 这里根据事物级别不同有时需要\ncur.commit</p></li>\n<li><p>关闭 cur 与 com</p></li>\n</ul>\n</blockquote>\n\n<p><strong>python 实例</strong></p>\n\n<blockquote>\n<ul>\n<li>导入模块</li>\n</ul>\n</blockquote>\n\n<pre><code>import sqlite3\n</code></pre>\n\n<blockquote>\n<ul>\n<li>创建打开数据库 (存在则打开不存在则创建)</li>\n</ul>\n</blockquote>\n\n<pre><code>com=sqlite3.connect(\"sql.db\")\n</code></pre>\n\n<blockquote>\n<ul>\n<li>返回的 com 是一个数据库连接对象 它有如下的操作</li>\n</ul>\n<blockquote>\n<ul>\n<li>commit()   提交事务</li>\n<li>rollback()  事务回滚</li>\n<li>close()    关闭数据库连接</li>\n<li>cursor()    创建游标</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>python  sqlite3 游标的使用</li>\n</ul>\n<blockquote>\n<ul>\n<li>游标提供了一种从表中检索数据的简单方法</li>\n<li>游标本质上是一种可以从多个结果集中取出一条记录的机制</li>\n<li>游标是由__结果集__以及指定特定位置的__游标位置__</li>\n<li><p>可以把游标比喻为文件句柄</p></li>\n<li><p>创建游标对象</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cur=com.cursor\n</code></pre>\n\n<p>游标对象 cur 常用操作</p>\n\n<blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>execute()  执行sql 语句</li>\n<li>executemany  执行多条sql语句</li>\n<li>close()    关闭游标</li>\n<li>fetchone()  从结果中取出一条记录 并把游标指向下一个</li>\n<li>fetchmany()  从结果中取出多条记录。并移动游标</li>\n<li>fetchall()   从结果中取出所有记录<br>\n</li>\n<li>scroll()  滚动游标</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>建表</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cu.execute(\'create table catalog (id integer primary key,pid integer,name varchar(10) UNIQUE）\') \n</code></pre>\n\n<p>建立 表 catalog  主键为 id </p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li> 插入数据库</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cu.execute(\"insert into catalog values(0, 0, \'name1\')\")  \ncu.execute(\"insert into catalog values(1, 0, \'hello\')\")\n</code></pre>\n\n<p><strong>注意:这样子插入需要自己做特殊字符的转义</strong></p>\n\n<p>sqlite3 中的处理方法</p>\n\n<pre><code>  executeTemplate=\"insert into  blog_entries(href,title,text) values (?,?,?)\" \n  com.execute(executeTemplate,(globalName[key][\'href\'],globalName[key][\'title\'],globalName[key][\'content\']))\n</code></pre>\n\n<p>mysql 中的处理方法</p>\n\n<pre><code>  import MySQLdb\n  s = \"\"\"test!42\'\'354542\"\"\"\n  print MySQLdb.escape_string(s)\n</code></pre>\n\n<p>这里需要注意需要使用连接对象提交 com.commit 才能生效</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li> 查询</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cu.execute(\"select * from catalog\")\nprint cu.fetchall()  打印所有结果\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>修改 </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cu.execute(\"update catalog set name=\'name2\' where id = 0\") \ncx.commit() 注意,修改数据以后提交\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>删除</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cu.execute(\"delete from catalog where id = 1\")  \ncx.commit()\n</code></pre>\n\n<p><strong>note:可以通过修改 conn.isolation_level = None 避免每次都需要commit的麻烦</strong></p>\n\n<p><a href=\"https://gist.github.com/xiyoulaoyuanjia/31bb4783c900123cc7e3\">完整示例</a></p>','/xiyoulaoyuanjia/blog/blob/master/python%20%E4%B8%AD%20sqlite3%20%E7%9A%84%E4%BD%BF%E7%94%A8.md','af0f0ace930e612d2a52009b858acaba-fc0f8e9f1a3e8d26e9124b3ddfaa2df6214c54fe','<h1>\n<a name=\"python--sqlite3-\" class=\"anchor\" href=\"#python--sqlite3-\"><span class=\"mini-icon mini-icon-link\"></span></a>python 中 sqlite3 的使用</h1>\n\n<p><strong>优点使用方便但是功能相比较其它大型数据库有所差距</strong></p>\n\n<p><strong>python的数据库模块有统一的接口，操作基本有统一的模式</strong> </p>\n\n<p>假设数据库模块名称为 sqlite3</p>\n\n<blockquote>\n<ul>\n<li>创建数据库连接 sqlite3.connect,返回连接对象为com</li>\n<li>如果不需要返回结果可以直接com.execute 查询。有时需要使用 com.commit 提交事务</li>\n<li><p>如果需要查询返回结果。则需要使用游标 com.cursor 创建游标对象 cur.. 通过cur.execute 查询数据库\n用 cur.fetchall/cur.fetchone/cur.fetchmany 获取查询结果. 这里根据事物级别不同有时需要\ncur.commit</p></li>\n<li><p>关闭 cur 与 com</p></li>\n</ul>\n</blockquote>\n\n<p><strong>python 实例</strong></p>\n\n<blockquote>\n<ul>\n<li>导入模块</li>\n</ul>\n</blockquote>\n\n<pre><code>import sqlite3\n</code></pre>\n\n<blockquote>\n<ul>\n<li>创建打开数据库 (存在则打开不存在则创建)</li>\n</ul>\n</blockquote>\n\n<pre><code>com=sqlite3.connect(\"sql.db\")\n</code></pre>\n\n<blockquote>\n<ul>\n<li>返回的 com 是一个数据库连接对象 它有如下的操作</li>\n</ul>\n<blockquote>\n<ul>\n<li>commit()   提交事务</li>\n<li>rollback()  事务回滚</li>\n<li>close()    关闭数据库连接</li>\n<li>cursor()    创建游标</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>python  sqlite3 游标的使用</li>\n</ul>\n<blockquote>\n<ul>\n<li>游标提供了一种从表中检索数据的简单方法</li>\n<li>游标本质上是一种可以从多个结果集中取出一条记录的机制</li>\n<li>游标是由__结果集__以及指定特定位置的__游标位置__</li>\n<li><p>可以把游标比喻为文件句柄</p></li>\n<li><p>创建游标对象</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>cur=com.cursor\n</code></pre>\n\n<p>游标对象 cur 常用操作</p>'),(8,'oauth 解释 以及新浪微薄OAuth python实现.md','<h1>\n<a name=\"oauth--oauth-python\" class=\"anchor\" href=\"#oauth--oauth-python\"><span class=\"mini-icon mini-icon-link\"></span></a>oauth 解释 以及新浪微薄OAuth python实现</h1>\n\n<p><strong>什么是oauth？</strong></p>\n\n<p>oauth是一套认证标准 。最早出现在 <a href=\"http://oauth.net/\">这里</a> 当然这样的标准分为 oauth1 与 oauth2</p>\n\n<p>oauth 是一套三方委托认证模式</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/2cee7e55f0e6e8fd50eb29543a72065144816dd9/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d3363383865385976476c785a6c537a56625875572d2d32464855772d2d3242484d6d7275676b54633638536b512d2d3242616359323262477953354f413548665a5639617a517232314c475258776d67782d2d324263475152644c584c53466a61334f4d2d2d3242336a7a\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/2cee7e55f0e6e8fd50eb29543a72065144816dd9/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d3363383865385976476c785a6c537a56625875572d2d32464855772d2d3242484d6d7275676b54633638536b512d2d3242616359323262477953354f413548665a5639617a517232314c475258776d67782d2d324263475152644c584c53466a61334f4d2d2d3242336a7a\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>ZYS 向SINA 发出请求 获得YQ的信息,SINA询问YQ是否同意？ YQ返回同意。然后SINA返回ZYS请求的信息 \"here you are\"</p>\n\n<p>可以概括起来就是 </p>\n\n<blockquote>\n<ul>\n<li>request</li>\n<li>argee?</li>\n<li>Yes</li>\n<li>Here you are</li>\n</ul>\n</blockquote>\n\n<p>上面的3个对应于新浪的3个认证URL 最后一个 \"Here you are\" 可以看成具体的应用API调用</p>\n\n<blockquote>\n<ul>\n<li><p><a href=\"http://api.t.sina.com.cn/oauth/request_token\">http://api.t.sina.com.cn/oauth/request_token</a></p></li>\n<li><p><a href=\"http://api.t.sina.com.cn/oauth/authorize\">http://api.t.sina.com.cn/oauth/authorize</a></p></li>\n<li><p><a href=\"http://api.t.sina.com.cn/oauth/access_token\">http://api.t.sina.com.cn/oauth/access_token</a></p></li>\n</ul>\n</blockquote>\n\n<p>这其中牵扯的一些参数</p>\n\n<blockquote>\n<ul>\n<li><p>APP_KEY, APP_SECRET</p></li>\n<li><p>request_token, request_secret</p></li>\n<li><p>verifier</p></li>\n</ul>\n</blockquote>\n\n<p>URL 编码 参考<a href=\"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html\">这里</a></p>\n\n<blockquote>\n<ul>\n<li>access_secret, access_secret</li>\n</ul>\n</blockquote>\n\n<p>这个认证步骤可以看成</p>\n\n<p>ZYS YQ SINA</p>\n\n<blockquote>\n<ul>\n<li><p>ZYS 找到SINA 说等会 YQ过来我要拿YQ的粉丝数据。然后通过参数的传递 从SINA处获得__request_token__ 和 <strong>request_secret</strong></p></li>\n<li><p>YQ 找到SNA说是否ZYS要我的粉丝数据?并且把ZYS私下给YQ的__request_token__和 <strong>request_secret</strong> 给SINA看，并同意ZYS拿它的数据。这时SNA把__verifier__给 YQ。YQ把__verifier__ 给了\nZYS</p></li>\n<li><p>ZYS 拿着 request_token ， request_secret ， verifier 这三样东西，找到 SINA，说明他已经取得了 YQ 的授权。此时， SINA 给了 ZYS 一对 access_token 和 access_secret 。之后，凭着这对东西， ZYS 就可以从 SINA 那里取得 YQ 的粉丝数据了。</p></li>\n</ul>\n</blockquote>\n\n<p><em>以后ZYS就可以使用access_token从SINA处直接获得数据了(对外API)</em></p>\n\n<p>实战参考<a href=\"http://zouyesheng.com/oauth-sina.html#toc1\">这里</a></p>','/xiyoulaoyuanjia/blog/blob/master/oauth%20%E8%A7%A3%E9%87%8A%20%E4%BB%A5%E5%8F%8A%E6%96%B0%E6%B5%AA%E5%BE%AE%E8%96%84OAuth%20python%E5%AE%9E%E7%8E%B0.md','e3cf39070935dedf4008376912e146cf-ca89df78aeabb0c39763fbfb9191592d467a47db','<h1>\n<a name=\"oauth--oauth-python\" class=\"anchor\" href=\"#oauth--oauth-python\"><span class=\"mini-icon mini-icon-link\"></span></a>oauth 解释 以及新浪微薄OAuth python实现</h1>\n\n<p><strong>什么是oauth？</strong></p>\n\n<p>oauth是一套认证标准 。最早出现在 <a href=\"http://oauth.net/\">这里</a> 当然这样的标准分为 oauth1 与 oauth2</p>\n\n<p>oauth 是一套三方委托认证模式</p>'),(9,'cookies and 缓存.md','<p><strong>cookie 的分类</strong></p>\n\n<blockquote>\n<ul>\n<li>会话cookies</li>\n</ul>\n</blockquote>\n\n<p>是一种临时cookies。记录用户登录网站的设置与偏好信息。。关闭浏览器就清除了</p>\n\n<blockquote>\n<ul>\n<li>持久cookies</li>\n</ul>\n</blockquote>\n\n<p>持久icookies 存在硬盘中。。有过期时间</p>\n\n<p><strong>为什么需要cookies</strong></p>\n\n<p>这是因为http协议是无状态的。。对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器\n所以浏览器需要额外的信息维持会话。。</p>\n\n<p><strong>cookies 的限制</strong>\n一些浏览器支持最大 4096字节的cookies。另一些支持最多20个cookies 超过的旧的就会陪删除</p>\n\n<p><strong>cookie 存放</strong></p>\n\n<blockquote>\n<ul>\n<li>不同的浏览器会存放在不同的地方</li>\n<li>不同的网站会有不同的cookie文件</li>\n</ul>\n</blockquote>\n\n<p>windows 下的ie 是 存放在临时文件夹下面的\n<a href=\"https://a248.e.akamai.net/camo.github.com/b976d8a61ba9c511562c68926f9f133fc072be93/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6238643858676950566442776c2d2d32464531634456777661566d57626252453458434e74542d2d32466c5931784a6a64504474706157553673754c4e4a6f3337776556317a424537634242666738522d2d32426d4d4633425336374248306369486c687a\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/b976d8a61ba9c511562c68926f9f133fc072be93/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6238643858676950566442776c2d2d32464531634456777661566d57626252453458434e74542d2d32466c5931784a6a64504474706157553673754c4e4a6f3337776556317a424537634242666738522d2d32426d4d4633425336374248306369486c687a\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>linux 下的 chrome 是存放在 sqllite3 数据库中的\n<a href=\"https://a248.e.akamai.net/camo.github.com/a8c12cafab35e16e5426d8fa0a92b1b1f04312eb/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d366331374738487952527738755553444d74676d6e4376366a59536e58584d735a49434e73707a356c556a57723733356d6663625234714261793553763963364269556f45384c34505953695938425345384f794351642d2d3242444b4262\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/a8c12cafab35e16e5426d8fa0a92b1b1f04312eb/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d366331374738487952527738755553444d74676d6e4376366a59536e58584d735a49434e73707a356c556a57723733356d6663625234714261793553763963364269556f45384c34505953695938425345384f794351642d2d3242444b4262\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>cookies 在 http中的使用</strong></p>\n\n<p>浏览器把 cookies 在 http 的 Request 中 Cookie: header 发送</p>\n\n<p>Web服务器通过HTTP Response中的\"Set-Cookie: header\"把cookie发送给浏览器</p>\n\n<p><strong>cookies 与文件缓存的区别</strong></p>\n\n<p>这两个是不一样的东西。。。在ie中可能存放在同一个文件夹下。。但一般在设置浏览器时\n都可以选择分别设置cookies 与 缓存的</p>\n\n<p><strong>http协议之缓存</strong></p>\n\n<blockquote>\n<ul>\n<li>http 中具有浏览器缓存。缓存代理服务器</li>\n<li> http 缓存是指当web 请求到达缓存时可以考虑从本地提取缓存而不用在次从服务器发请求</li>\n<li>\n<p>缓存的好处</p>\n\n<blockquote>\n<ul>\n<li>减少了服务器的压力</li>\n<li>加快了浏览器的加载速度</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>与缓存有关的header</p>\n\n<blockquote>\n<ul>\n<li>Request</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n\n<pre><code>Cache-Control: max-age=0    以秒为单位\nIf-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT  缓存文件的最后修改时间。\nIf-None-Match: \"0693f67a67cc1:0\"    缓存文件的Etag值\nCache-Control: no-cache            不使用缓存\nPragma: no-cache               不使用缓存\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>Response</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>Cache-Control: public    响应被缓存，并且在多用户间共享，  （公有缓存和私有缓存的区别，请看另一节）\nCache-Control: private  响应只能作为私有缓存，不能在用户之间共享\nCache-Control:no-cache  提醒浏览器要从服务器提取文档进行验证\nCache-Control:no-store  绝对禁止缓存（用于机密，敏感文件）\nCache-Control: max-age=60   60秒之后缓存过期（相对时间）\nDate: Mon, 19 Nov 2012 08:39:00 GMT 当前response发送的时间\nExpires: Mon, 19 Nov 2012 08:40:01 GMT  缓存过期的时间（绝对时间）\nLast-Modified: Mon, 19 Nov 2012 08:38:01 GMT    服务器端文件的最后修改时间\nETag: \"20b1add7ec1cd1:0\"    服务器端文件的Etag值\n</code></pre>\n\n<blockquote>\n<ul>\n<li>如何判断缓存的新鲜度\n这里的新鲜度指文件是否修改。提出了两种方法</li>\n</ul>\n<blockquote>\n<ul>\n<li>文件的最后修改时间  在head 中通过  \"If-Modified-Since\" 字段标识</li>\n</ul>\n<blockquote>\n<ul>\n<li>服务器发送状态吗 304 来标识没有修改</li>\n<li>如图</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<p>文件没有修改\n<a href=\"https://a248.e.akamai.net/camo.github.com/81ffb61bf983d1c95a2a64f0b6f70c23df85b5c4/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d62663038376e5233624d733255674f4579754e5a7549535634786d772d2d32466b4b652d2d32466d5368476a354c476f58774456504a7139413033753166524a36746e69315434346650336676556b53555a426250315772347638456e4e2d2d3246385448\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/81ffb61bf983d1c95a2a64f0b6f70c23df85b5c4/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d62663038376e5233624d733255674f4579754e5a7549535634786d772d2d32466b4b652d2d32466d5368476a354c476f58774456504a7139413033753166524a36746e69315434346650336676556b53555a426250315772347638456e4e2d2d3246385448\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>文件已经修改\n<a href=\"https://a248.e.akamai.net/camo.github.com/c6beea56ae03ac3999ae4778a4936e113e58c6bf/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d646666346b5365694268326d536d6c71636f4d664a615056744979647656553851514b7854797333797631763050782d2d32425330447a6b77694e317a3349652d2d32424447306f676b705969736b454b4e6b624e575951394d767942506f6d7051\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/c6beea56ae03ac3999ae4778a4936e113e58c6bf/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d646666346b5365694268326d536d6c71636f4d664a615056744979647656553851514b7854797333797631763050782d2d32425330447a6b77694e317a3349652d2d32424447306f676b705969736b454b4e6b624e575951394d767942506f6d7051\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li> 文件的hash 签名 Etag 在head 中通过  \"If-None-Match\" 字段来标识  Etag 是可以看成是对 最后修改时间的一种补充\n*  有些服务器没有办法获得文件的最后修改时间\n*  If-Modified-Since 是精确到秒的 对于 秒以下的文件修改则没有办法\n*  一些文件最后修改时间变了。内容却没有改变</li>\n</ul>\n</blockquote>\n\n<ul>\n<li>直接使用缓存不去服务器验证\n这里 说一个例子\n按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。</li>\n</ul>\n<blockquote>\n<ul>\n<li>在浏览器里输入网址 然后按回车 会直接使用缓存 不去服务器验证的。。。</li>\n<li>F5刷新 需要验证</li>\n</ul>\n</blockquote>\n</blockquote>','/xiyoulaoyuanjia/blog/blob/master/cookies%20and%20%E7%BC%93%E5%AD%98.md','a729f31a09209840b3a71985616a45c3-5c16f4d10ab6380b0ecf9426d32d667e7374d66c','<p><strong>cookie 的分类</strong></p>\n\n<blockquote>\n<ul>\n<li>会话cookies</li>\n</ul>\n</blockquote>\n\n<p>是一种临时cookies。记录用户登录网站的设置与偏好信息。。关闭浏览器就清除了</p>\n\n<blockquote>\n<ul>\n<li>持久cookies</li>\n</ul>\n</blockquote>\n\n<p>持久icookies 存在硬盘中。。有过期时间</p>\n\n<p><strong>为什么需要cookies</strong></p>\n\n<p>这是因为http协议是无状态的。。对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器\n所以浏览器需要额外的信息维持会话。。</p>\n\n<p><strong>cookies 的限制</strong>\n一些浏览器支持最大 4096字节的cookies。另一些支持最多20个cookies 超过的旧的就会陪删除</p>\n\n<p><strong>cookie 存放</strong></p>\n\n<blockquote>\n<ul>\n<li>不同的浏览器会存放在不同的地方</li>\n<li>不同的网站会有不同的cookie文件</li>\n</ul>\n</blockquote>'),(10,'python_装饰器.md','<h1>\n<a name=\"python-\" class=\"anchor\" href=\"#python-\"><span class=\"mini-icon mini-icon-link\"></span></a>python 装饰器</h1>\n\n<p>概括来讲..装饰器就是为已经存在的对象添加额外的一些功能</p>\n\n<blockquote>\n<ul>\n<li>装饰器入门</li>\n</ul>\n<blockquote>\n<ul>\n<li>需求是怎么来的?</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>def foo():\n    print \'in foo()\'     \nfoo()\n</code></pre>\n\n<p>现在需要计算机foo 函数用的时间. 一般来说这可能想到了使用 如下代码</p>\n\n<pre><code>import time\ndef foo():\n    start = time.clock()\n    print \'in foo()\'\n    end = time.clock()\n    print \'used:\', end - start\n\nfoo()\n</code></pre>\n\n<p>如果其他函数也有这个需求呢? 复制? 很可笑....</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>以不变应万变</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>import time\n \ndef foo():\n    print \'in foo()\'\n \ndef timeit(func):\n    start = time.clock()\n    func()\n    end =time.clock()\n    print \'used:\', end - start\n \ntimeit(foo)\n</code></pre>\n\n<p>这样子的一个问题是更改了调用接口.本来是  timeit 方法调用.现在换成了 timeit(foo) 调用方法\n如果其它地方也有这个就需要修改其它地方了...</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>最大限度地少改动！</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>#-*- coding: UTF-8 -*-\nimport time\n \ndef foo():\n    print \'in foo()\'\n \n# 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法\ndef timeit(func):\n     \n    # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装\n    def wrapper():\n        start = time.clock()\n        func()\n        end =time.clock()\n        print \'used:\', end - start\n     \n    # 将包装后的函数返回\n    return wrapper\n \nfoo = timeit(foo)\nfoo()\n</code></pre>\n\n<p>上面的最后两行代码也就是体现了装饰器的思想</p>\n\n<blockquote>\n<ul>\n<li>python 的 额外支持</li>\n</ul>\n<blockquote>\n<ul>\n<li>语法 @ </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>@timeit\ndef foo():\n    print \'in foo()\'\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>内置的装饰器</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。</p>\n\n<p>这里，静态方法，虽然是一个方法，但是a.static_foo只是一个没有绑定任何参数的完好的函数。static_foo需要1个参数，同样a.static_foo也只需要一个参数。</p>\n\n<p>这里有一个很好的链接的关于上面的....\n<a href=\"http://www.zeuux.com/blog/content/3030/\">http://www.zeuux.com/blog/content/3030/</a></p>','/xiyoulaoyuanjia/blog/blob/master/python_%E8%A3%85%E9%A5%B0%E5%99%A8.md','5a3e1c150bcea5e97c0fca66271c0d67-35477248ab2a73b4cc746e726b71859c05d4c326','<h1>\n<a name=\"python-\" class=\"anchor\" href=\"#python-\"><span class=\"mini-icon mini-icon-link\"></span></a>python 装饰器</h1>\n\n<p>概括来讲..装饰器就是为已经存在的对象添加额外的一些功能</p>\n\n<blockquote>\n<ul>\n<li>装饰器入门</li>\n</ul>\n<blockquote>\n<ul>\n<li>需求是怎么来的?</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>def foo():\n    print \'in foo()\'     \nfoo()\n</code></pre>\n\n<p>现在需要计算机foo 函数用的时间. 一般来说这可能想到了使用 如下代码</p>\n\n<pre><code>import time\ndef foo():\n    start = time.clock()\n    print \'in foo()\'\n    end = time.clock()\n    print \'used:\', end - start\n\nfoo()\n</code></pre>\n\n<p>如果其他函数也有这个需求呢? 复制? 很可笑....</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>以不变应万变</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>import time\n \ndef foo():\n    print \'in foo()\'\n \ndef timeit(func):\n    start = time.clock()\n    func()\n    end =time.clock()\n    print \'used:\', end - start\n \ntimeit(foo)\n</code></pre>\n\n<p>这样子的一个问题是更改了调用接口.本来是  timeit 方法调用.现在换成了 timeit(foo) 调用方法\n如果其它地方也有这个就需要修改其它地方了...</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>最大限度地少改动！</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>#-*- coding: UTF-8 -*-\nimport time\n \ndef foo():\n    print \'in foo()\'\n \n# 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法\ndef timeit(func):\n     \n    # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装\n    def wrapper():\n        start = time.clock()\n        func()\n        end =time.clock()\n        print \'used:\', end - start\n     \n    # 将包装后的函数返回\n    return wrapper\n \nfoo = timeit(foo)\nfoo()\n</code></pre>\n\n<p>上面的最后两行代码也就是体现了装饰器的思想</p>\n\n<blockquote>\n<ul>\n<li>python 的 额外支持</li>\n</ul>\n<blockquote>\n<ul>\n<li>语法 @ </li>\n</ul>\n</blockquote>\n</blockquote>\n\n<pre><code>@timeit\ndef foo():\n    print \'in foo()\'\n</code></pre>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>内置的装饰器</li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。</p>\n\n<p>这里，静态方法，虽然是一个方法，但是a.static_foo只是一个没有绑定任何参数的完好的函数。static_foo需要1个参数，同样a.static_foo也只需要一个参数。</p>\n\n<p>这里有一个很好的链接的关于上面的....\n<a href=\"http://www.zeuux.com/blog/content/3030/\">http://www.zeuux.com/blog/content/3030/</a></p>'),(11,'python 解析HTML文件.md','<h1>\n<a name=\"-htmlparserhtml\" class=\"anchor\" href=\"#-htmlparserhtml\"><span class=\"mini-icon mini-icon-link\"></span></a> HTMLParser解析HTML文件</h1>\n\n<p><a href=\"http://docs.python.org/2/library/htmlparser.html\">python doc 文档</a></p>\n\n<p>HTMLParser采用的是一种事件驱动的模式(必须覆写如下列出的几种函数)，当HTMLParser找到一个特定的标记时，它会去调用一个用户定义的函数，以此来通知程序处理</p>\n\n<p>主要的用户回调函数都是已 handler_ 开头的函数 这里列出以下常用的几种</p>\n\n<blockquote>\n<ul>\n<li>handle_startendtag 处理开始标签和结束标签 </li>\n<li>handle_starttag 处理开始标签，比如 <code>xx</code>\n</li>\n<li>handle_endtag 处理结束标签，比如 <code>/xx</code>\n</li>\n<li>handle_comment 处理注释\n详细的可以查看 文档</li>\n</ul>\n</blockquote>','/xiyoulaoyuanjia/blog/blob/master/python%20%E8%A7%A3%E6%9E%90HTML%E6%96%87%E4%BB%B6.md','1952ca6e182d58ec3e90026ee241e4f7-ace8a275c902b59573d3472c8329301c9260bb78','<h1>\n<a name=\"-htmlparserhtml\" class=\"anchor\" href=\"#-htmlparserhtml\"><span class=\"mini-icon mini-icon-link\"></span></a> HTMLParser解析HTML文件</h1>\n\n<p><a href=\"http://docs.python.org/2/library/htmlparser.html\">python doc 文档</a></p>\n\n<p>HTMLParser采用的是一种事件驱动的模式(必须覆写如下列出的几种函数)，当HTMLParser找到一个特定的标记时，它会去调用一个用户定义的函数，以此来通知程序处理</p>\n\n<p>主要的用户回调函数都是已 handler_ 开头的函数 这里列出以下常用的几种</p>\n\n<blockquote>\n<ul>\n<li>handle_startendtag 处理开始标签和结束标签 </li>\n<li>handle_starttag 处理开始标签，比如 <code>xx</code>\n</li>\n<li>handle_endtag 处理结束标签，比如 <code>/xx</code>\n</li>\n<li>handle_comment 处理注释\n详细的可以查看 文档</li>\n</ul>\n</blockquote>'),(12,'使用ajax上传文档.md','<h1>\n<a name=\"ajax\" class=\"anchor\" href=\"#ajax\"><span class=\"mini-icon mini-icon-link\"></span></a>使用ajax上传文档</h1>\n\n<p><strong>note:<a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/uploading-files-with-ajax\">E文</a></strong></p>\n\n<p><strong><a href=\"http://nettuts.s3.amazonaws.com/1020_ajaxupload/demo.zip\">代码</a></strong></p>\n\n<p><strong>为什么不在最后告诉你这个不好的消息呢?这个并不是在每一个浏览器中都适用的</strong></p>\n\n<p>我们项目用到的主要的3个组建</p>\n\n<blockquote>\n<ul>\n<li>\"\"input 中的  multiple 属性(这个支持多个文件)</li>\n<li>文件操作的API 中的 FileReader 对象</li>\n<li>在 XMLHttpRequest2 中的  FormData 对象</li>\n</ul>\n</blockquote>\n\n<p>我们使用 multiple 属性允许我们读取多个文件内容(即使 FileReader 对象不可用.这个依然可以正常使用) 当然,FileReader对象可以使用们在上传的时候看到图片的缩略图.</p>\n\n<p>上述3个特性均不能在IE9中正常的工作.所以 IE用户可能不能正常使用.在最新的 Safari (5.1)版本中没有FileReader 对象 所以用户不能得到正常的图片缩略图 但是可以使用AJAX正常上传图片并获得上传成功的消息.,Opera 10.50 版本支持FileReader 对象 对象但是不支持 FormData 对象所以可以获得缩略图但是不能正确的上传图片.</p>\n\n<p>先抛开那些问题,开始看代码吧.</p>\n\n<p><strong>标签与样式</strong></p>\n\n<p>让我们从基本的标签与样式开始吧..当然这些不是本文档的主要部分..就向我不会把你们当成初学者一样..</p>\n\n<p><strong>html部分</strong></p>\n\n<p>!DOCTYPE html\n\n</p>\n    HTML5 File API<div>\n        <h1>\n<a name=\"upload-your-images\" class=\"anchor\" href=\"#upload-your-images\"><span class=\"mini-icon mini-icon-link\"></span></a>Upload Your Images</h1>\n        \n            Upload Files!\n        \n\n<pre><code>    div id=\"response\"/div\n    ul id=\"image-list\"\n\n    /ul\n/div\n\nscript src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js\"/script\nscript src=\"upload.js\"/script\n</code></pre>\n\n<p>\n</p>\n\n<p>上面的代码很基本吧..有一个form表格.并且post到 upload.php (这个文件等会会看到),然后还有一个input组建允许我们选择多个需要上传的文件,当然这个是 multiple 属性 起作用的.</p>\n\n<p>继续吧..</p>\n\n<p>body {\n    font: 14px/1.5 helvetica-neue, helvetica, arial, san-serif;\n    padding:10px;\n}</p>\n\n<p>h1 {\n    margin-top:0;\n}</p>\n\n<h1>\n<a name=\"main-\" class=\"anchor\" href=\"#main-\"><span class=\"mini-icon mini-icon-link\"></span></a>main {</h1>\n\n<pre><code>width: 300px;\nmargin:auto;\nbackground: #ececec;\npadding: 20px;\nborder: 1px solid #ccc;\n</code></pre>\n\n<p>}</p>\n\n<h1>\n<a name=\"image-list-\" class=\"anchor\" href=\"#image-list-\"><span class=\"mini-icon mini-icon-link\"></span></a>image-list {</h1>\n\n<pre><code>list-style:none;\nmargin:0;\npadding:0;\n</code></pre>\n\n<p>}</p>\n\n<h1>\n<a name=\"image-list-li-\" class=\"anchor\" href=\"#image-list-li-\"><span class=\"mini-icon mini-icon-link\"></span></a>image-list li {</h1>\n\n<pre><code>background: #fff;\nborder: 1px solid #ccc;\ntext-align:center;\npadding:20px;\nmargin-bottom:19px;\n</code></pre>\n\n<p>}</p>\n\n<h1>\n<a name=\"image-list-li-img-\" class=\"anchor\" href=\"#image-list-li-img-\"><span class=\"mini-icon mini-icon-link\"></span></a>image-list li img {</h1>\n\n<pre><code>width: 258px;\nvertical-align: middle;\nborder:1px solid #474747;\n</code></pre>\n\n<p>}</p>\n\n<p>完全的css文件没有什么要说的...</p>\n\n<p><strong>php文档</strong></p>\n\n<p>对于前台提出的请求是在这里进行处理的.可以在下面的代码中看出来</p>\n\n<p>?php</p>\n\n<p>foreach ($_FILES[\"images\"][\"error\"] as $key = $error) {\n    if ($error == UPLOAD_ERR_OK) {\n        $name = $_FILES[\"images\"][\"name\"][$key];\n        move_uploaded_file( $_FILES[\"images\"][\"tmp_name\"][$key], \"uploads/\" . $_FILES[\'images\'][\'name\'][$key]);\n    }\n}</p>\n\n<p>echo \"</p>\n<h2>\n<a name=\"successfully-uploaded-images\" class=\"anchor\" href=\"#successfully-uploaded-images\"><span class=\"mini-icon mini-icon-link\"></span></a>Successfully Uploaded Images</h2>\";\n\n<p>请记住这个是我进一年来首次使用php语言.(我是一个rubyer),当然你需要确保安全性..这些可以使用内置的move_uploaded_file 移动到需要上传的文件夹内.不要忘记文件夹是可写的..</p>\n\n<p>现在我们有一个前台的form表单.后台的php文件.可以开始做了,选择需要上传的图片并且点击上传按钮..然后你会看到”Successfully Uploaded Images “ 的消息</p>\n\n<p>我们的mini的项目看起来是如下的样子的</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/587a0ba841e40e6190980f0d355186c1fa365af4/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f363161303736313630363035653233663531616563383938343063333939346332393666363030373f69703d313336343435353233362c3231392e3134322e352e32333426737369673d6b6d25324641617544566d7026457870697265733d31333634343534303336264b49443d7361652c6c33307a6f6f31776d7a26666e3d666f726d2e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/587a0ba841e40e6190980f0d355186c1fa365af4/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f363161303736313630363035653233663531616563383938343063333939346332393666363030373f69703d313336343435353233362c3231392e3134322e352e32333426737369673d6b6d25324641617544566d7026457870697265733d31333634343534303336264b49443d7361652c6c33307a6f6f31776d7a26666e3d666f726d2e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>但是请记住.现在是2011,我们想做的肯定不止这些..聪明的人已经看到我们引入了 upload.js 和 jQuery 文件  那我们就开始吧</p>\n\n<p><strong>javascript 文件</strong></p>\n\n<p>不要浪费时间了直接开始吧..</p>\n\n<p>(function () {\n    var input = document.getElementById(\"images\"),\n        formdata = false;</p>\n\n<pre><code>if (window.FormData) {\n    formdata = new FormData();\n    document.getElementById(\"btn\").style.display = \"none\";\n}\n</code></pre>\n\n<p>}();</p>\n\n<p>从上面代码开始吧..这里我们创造了两个变量.input是我们的 id为 images的 对象.\nformadata用来从前台向后台传递数据的对象当然这个需要浏览器的支持.当然如果浏览器支持这个我们也不需要 “Upload image ” 按钮了(选择需要上传的图片之后自动上传)..所以在后面我们隐藏了它..</p>\n\n<p>剩下的代码会在 匿名的  self-invoking 函数内 (<a href=\"http://stackoverflow.com/questions/3259496/jquery-document-ready-vs-self-calling-anonymous-function\">关于self-invoking 与document.ready的区别 见里</a>) 下面我先写了一个当选择文件确定是在界面的需要展示..</p>\n\n<p>function showUploadedItem (source) {\n    var list = document.getElementById(\"image-list\"),\n        li   = document.createElement(\"li\"),\n        img  = document.createElement(\"img\");\n    img.src = source;\n    li.appendChild(img);\n    list.appendChild(li);\n}\n该函数只有一个参数 图像的源地址.(底下我们可以知道这个是如何得到的) 我们创建了图片项,添加了图像的来源,并把它添加到list(dom结构中去)中去.</p>\n\n<p>下来我们选择需要上传的文档.并且由于onchange函数触发.把它显示到Dom结构中去.并且上传图片数据给后端服务器.</p>\n\n<p>if (input.addEventListener) {\n    input.addEventListener(\"change\", function (evt) {\n        var i = 0, len = this.files.length, img, reader, file;</p>\n\n<pre><code>    document.getElementById(\"response\").innerHTML = \"Uploading . . .\"\n\n    for ( ; i  len; i++ ) {\n        file = this.files[i];\n\n        if (!!file.type.match(/image.*/)) {\n\n        }   \n    }\n\n}, false);\n</code></pre>\n\n<p>}</p>\n\n<p>并且 我们不需要担心其它的问题 因为 iE 9 也支持 addEventListener 监听函数.\n那么当用户选择时我们最关心什么 ?第一我们创建了几个变量..下来 对于 LEN = this.files.length 这句话也很重要.因为我们需要通过LEN 的长度来循环获得所选的每一个文件.. 下来所要做的就是在循环的里面了..这需要对于每一个文件复制给变量这样有助于简化处理.. 下来使用了正则表达式来确定上传的是图像文件 ...</p>\n\n<p>好吧.如果我们已经有一个图像文件在手上.那么我们下一步该怎么做呢?</p>\n\n<p>if ( window.FileReader ) {\n    reader = new FileReader();\n    reader.onloadend = function (e) { \n        showUploadedItem(e.target.result);\n    };\n    reader.readAsDataURL(file);\n}\nif (formdata) {\n    formdata.append(\"images[]\", file);\n}</p>\n\n<p>首先我们检查 浏览器是否支持 创建一个 FileReader 对象.如果支持我们就创建一个这样的对象..</p>\n\n<p>下来当然是如何使用 FileReader 对象的问题了..通过把 file 传递给 文件对象reader.readAsDataURL 方法.. 当然这个方法可能并不想你想象的那样工作.它的url并没有通过函数返回,想法它是它是一url data 的方式读数据并变成对象的一部分...关于这部分参考<a href=\"http://m.csdn.net/article/2012-12-17/2812911\"></a></p>\n\n<p>考虑到 这一点我们需要在 FileReader 对象上面注册一个 onload 事件 在 成功通过 readAsDataURL 读取图片的 内容时可以通过 e.target.result 读取到的数据内容传递给之前建立的 showUploadedItem 函数去显示..</p>\n\n<p>接下来 检查 formdata 对象 如果 浏览器支持 formdata对象 则 formdata 就是一个对象的值 反之则为空.所以当有一个 formdata 对象时可以去 使用  append 方法添加 一个key 与 values 当然 对于多个文件,相同的key值要保证不会覆盖.</p>\n\n<p>在我们的多个文件循环里面 我们把每一个图片对象添加到 list中展示给用户并且都添加到了formdata 对象里面.在循环外面我们使用了 ajax去 做post请求.</p>\n\n<p>if (formdata) {\n    $.ajax({\n        url: \"upload.php\",\n        type: \"POST\",\n        data: formdata,\n        processData: false,\n        contentType: false,\n        success: function (res) {\n            document.getElementById(\"response\").innerHTML = res; \n        }\n    });\n}</p>\n\n<p>当然在这里我们还是检查了浏览器是否支持  formdata 格式 如果不支持可以考虑点击上传按钮来完成一般的文件上传.当然如果浏览器支持 那我们通过ajax 的post方法完成上传的效果..</p>\n\n<p>你应该已经对jquery的 $.ajax 方法很熟悉了吧...通过给它传递一个包含一系列选项的对象.包括.url,type success 函数(执行成功是调用的函数)  数据属性是 formdata 并且 特别需要注意 processData 与  contentType , 在一般的Jqury文档里面都可以看到 processData 默认为 true 依次来保证传递的在字串传里面(?A=afab=??),但是这里当然不需要这样子的.所所以把它设置为false . 我们仍然把 contentType 设置为false 以保证数据正确从客户端到服务器传送</p>\n\n<p>至此我们看看前面的效果....当你开始打开网页时效果如下:</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/9b9abcff5c20792e76c69e61fd7bf0d89639bbf4/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f373935613531666464623261393766383538316463323039343961313665646133303635376139613f69703d313336343435343837322c3231392e3134322e352e32333426737369673d4541446975384330764526457870697265733d31333634343533363732264b49443d7361652c6c33307a6f6f31776d7a26666e3d616a61782d73746172742e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/9b9abcff5c20792e76c69e61fd7bf0d89639bbf4/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f373935613531666464623261393766383538316463323039343961313665646133303635376139613f69703d313336343435343837322c3231392e3134322e352e32333426737369673d4541446975384330764526457870697265733d31333634343533363732264b49443d7361652c6c33307a6f6f31776d7a26666e3d616a61782d73746172742e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>当用户选择上传图片之后 如下图</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/d63787944eada1bff4e9d0513652e9be59d04e72/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f313464396338366538356363646364643932336336626230353765313536353738396236623631623f69703d313336343435343934382c3231392e3134322e352e32333426737369673d4256715a334a3035387026457870697265733d31333634343533373438264b49443d7361652c6c33307a6f6f31776d7a26666e3d616a61782d75706c6f61642e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/d63787944eada1bff4e9d0513652e9be59d04e72/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f313464396338366538356363646364643932336336626230353765313536353738396236623631623f69703d313336343435343934382c3231392e3134322e352e32333426737369673d4256715a334a3035387026457870697265733d31333634343533373438264b49443d7361652c6c33307a6f6f31776d7a26666e3d616a61782d75706c6f61642e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>上传结果</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/3467bb0219c1299171674faecc730af394b67983/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f386465656131303136353730636331623434363636306333626262333664396163633661653639353f69703d313336343435343936382c3231392e3134322e352e32333426737369673d73646862566273716d4726457870697265733d31333634343533373638264b49443d7361652c6c33307a6f6f31776d7a26666e3d616a61782d66696e6465722e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/3467bb0219c1299171674faecc730af394b67983/687474703a2f2f696d6167652e646174612e766469736b2e6d652f35353839303030372f386465656131303136353730636331623434363636306333626262333664396163633661653639353f69703d313336343435343936382c3231392e3134322e352e32333426737369673d73646862566273716d4726457870697265733d31333634343533373638264b49443d7361652c6c33307a6f6f31776d7a26666e3d616a61782d66696e6465722e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>总结</strong></p>\n\n<p>通过ajax上传图片这是意见很cool的事情..掌握它只需要一些常用的新支持而不需要很复杂的hack 很高兴你可以阅读它...再见.~~</p>\n</div>','/xiyoulaoyuanjia/blog/blob/master/%E4%BD%BF%E7%94%A8ajax%E4%B8%8A%E4%BC%A0%E6%96%87%E6%A1%A3.md','d354eb850485716b9512661ad780b670-5bce5ba8e1bb13de7f9567f483f7ff9d3a0c1d95','<h1>\n<a name=\"ajax\" class=\"anchor\" href=\"#ajax\"><span class=\"mini-icon mini-icon-link\"></span></a>使用ajax上传文档</h1>\n\n<p><strong>note:<a href=\"http://net.tutsplus.com/tutorials/javascript-ajax/uploading-files-with-ajax\">E文</a></strong></p>\n\n<p><strong><a href=\"http://nettuts.s3.amazonaws.com/1020_ajaxupload/demo.zip\">代码</a></strong></p>\n\n<p><strong>为什么不在最后告诉你这个不好的消息呢?这个并不是在每一个浏览器中都适用的</strong></p>\n\n<p>我们项目用到的主要的3个组建</p>\n\n<blockquote>\n<ul>\n<li>\"\"input 中的  multiple 属性(这个支持多个文件)</li>\n<li>文件操作的API 中的 FileReader 对象</li>\n<li>在 XMLHttpRequest2 中的  FormData 对象</li>\n</ul>\n</blockquote>\n\n<p>我们使用 multiple 属性允许我们读取多个文件内容(即使 FileReader 对象不可用.这个依然可以正常使用) 当然,FileReader对象可以使用们在上传的时候看到图片的缩略图.</p>\n\n<p>上述3个特性均不能在IE9中正常的工作.所以 IE用户可能不能正常使用.在最新的 Safari (5.1)版本中没有FileReader 对象 所以用户不能得到正常的图片缩略图 但是可以使用AJAX正常上传图片并获得上传成功的消息.,Opera 10.50 版本支持FileReader 对象 对象但是不支持 FormData 对象所以可以获得缩略图但是不能正确的上传图片.</p>\n\n<p>先抛开那些问题,开始看代码吧.</p>\n\n<p><strong>标签与样式</strong></p>\n\n<p>让我们从基本的标签与样式开始吧..当然这些不是本文档的主要部分..就向我不会把你们当成初学者一样..</p>\n\n<p><strong>html部分</strong></p>\n\n<p>!DOCTYPE html\n\n</p>'),(13,'在线markdown编辑器的说明文档.md','<h1>\n<a name=\"markdown\" class=\"anchor\" href=\"#markdown\"><span class=\"mini-icon mini-icon-link\"></span></a>在线markdown编辑器的说明文档</h1>\n\n<p><strong>关于布局</strong></p>\n\n<p>分为左右两个div 左边是一个ace的编辑器的类型 右边是一个idiv 里面有一个iframe 结构</p>\n\n<p><strong>关于ace</strong></p>\n\n<p>详细见 <a href=\"http://ace.ajax.org/\">这里</a></p>\n\n<p><strong>关于左边的样式</strong></p>\n\n<p>向  var editor = ace.edit(\"editor\"); 这样id为editor的div 就变成一个ace的对象了..修改主题与提取values就变得\n十分的简单了</p>\n\n<p><strong>关于右边的iframe 结构</strong></p>\n\n<p>这里之所以选择iframe结构的原因是右边的内容是一个动态变化的过程(局部刷新),通过更改 iframe 的 src 的值就可以\n使右边从新加载内容</p>\n\n<p><strong>如何捕获左边div的变化(内容更改与复制动作)</strong></p>\n\n<p>这里还是使用了 ace 对象的 getSession().on(\'change\', function(e) 方法 刚开始使用onchange 监听事件后来发现\nonchange 只能监听写的动作对于复制动作不能捕获到</p>\n\n<p><strong>获得了内容之后如何把markdown转化为html?</strong></p>\n\n<p>这里使用了js 库 它的家在<a href=\"https://github.com/evilstreak/markdown-js\">这里</a></p>\n\n<p><strong>获得html源码之后如何显示到右边呢?</strong></p>\n\n<p>因为需要更改ifram的src 路径</p>\n\n<p>这里想了几个方案..</p>\n\n<blockquote>\n<ul>\n<li>反映到文本中 加载之后在删除?</li>\n<li>src 请求ajax请求并把html 源码传递到 后台.后台返回来? 这样子倒是可以但是服务器交互太多.</li>\n<li>不经过 修改src 路径的方案直接修改DOM的内容..尝试了几中方案都不行</li>\n</ul>\n</blockquote>\n\n<p>难道src不能直接加载html 源码吗?  </p>\n\n<p>最后终于在<a href=\"http://stackoverflow.com/questions/8240101/set-content-of-iframe\">这里</a>找到了答案</p>\n\n<pre><code>var locals = \"content\";\n\ndocument.getElementById(\'output_iframe1\').src = \"data:text/html;charset=utf-8,\" + escape(LocalS);\n</code></pre>','/xiyoulaoyuanjia/blog/blob/master/%E5%9C%A8%E7%BA%BFmarkdown%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3.md','2960a537007a89f5ab0e878442df17cd-f262eda9bf31cf007cb5256b14c5f9ba7dd0a4cd','<h1>\n<a name=\"markdown\" class=\"anchor\" href=\"#markdown\"><span class=\"mini-icon mini-icon-link\"></span></a>在线markdown编辑器的说明文档</h1>\n\n<p><strong>关于布局</strong></p>\n\n<p>分为左右两个div 左边是一个ace的编辑器的类型 右边是一个idiv 里面有一个iframe 结构</p>\n\n<p><strong>关于ace</strong></p>\n\n<p>详细见 <a href=\"http://ace.ajax.org/\">这里</a></p>\n\n<p><strong>关于左边的样式</strong></p>\n\n<p>向  var editor = ace.edit(\"editor\"); 这样id为editor的div 就变成一个ace的对象了..修改主题与提取values就变得\n十分的简单了</p>\n\n<p><strong>关于右边的iframe 结构</strong></p>\n\n<p>这里之所以选择iframe结构的原因是右边的内容是一个动态变化的过程(局部刷新),通过更改 iframe 的 src 的值就可以\n使右边从新加载内容</p>\n\n<p><strong>如何捕获左边div的变化(内容更改与复制动作)</strong></p>\n\n<p>这里还是使用了 ace 对象的 getSession().on(\'change\', function(e) 方法 刚开始使用onchange 监听事件后来发现\nonchange 只能监听写的动作对于复制动作不能捕获到</p>\n\n<p><strong>获得了内容之后如何把markdown转化为html?</strong></p>\n\n<p>这里使用了js 库 它的家在<a href=\"https://github.com/evilstreak/markdown-js\">这里</a></p>\n\n<p><strong>获得html源码之后如何显示到右边呢?</strong></p>\n\n<p>因为需要更改ifram的src 路径</p>\n\n<p>这里想了几个方案..</p>\n\n<blockquote>\n<ul>\n<li>反映到文本中 加载之后在删除?</li>\n<li>src 请求ajax请求并把html 源码传递到 后台.后台返回来? 这样子倒是可以但是服务器交互太多.</li>\n<li>不经过 修改src 路径的方案直接修改DOM的内容..尝试了几中方案都不行</li>\n</ul>\n</blockquote>\n\n<p>难道src不能直接加载html 源码吗?  </p>\n\n<p>最后终于在<a href=\"http://stackoverflow.com/questions/8240101/set-content-of-iframe\">这里</a>找到了答案</p>\n\n<pre><code>var locals = \"content\";\n\ndocument.getElementById(\'output_iframe1\').src = \"data:text/html;charset=utf-8,\" + escape(LocalS);\n</code></pre>'),(14,'github 上建立其它仓库的镜像.md','<h1>\n<a name=\"github-\" class=\"anchor\" href=\"#github-\"><span class=\"mini-icon mini-icon-link\"></span></a>github 上建立其它仓库的镜像</h1>\n\n<p><strong>github 上面建立Mercurial 仓库代码</strong></p>\n\n<p><strong>使用 <a href=\"https://github.com/schacon/hg-git\">hg-git</a> 工具</strong></p>\n\n<p>Hg-Git是Mercurial(Hg)的扩展插件,主要功能是 本地hg版本管理git代码pull(push) 到\ngit 服务器管理代码</p>\n\n<p>上面已经说了hg-git 是hg的一个扩展插件(其实就是一些python脚本)。。那安装hg-git的方式\n就与安装hg其它的插件一样。。</p>\n\n<pre><code>[extensions]\nhggit = /path/to/hg-git\n</code></pre>\n\n<p>/path/to/hg-git 一定要指示到下载的 hg-git 的python脚本目录 例如我的脚本目录为</p>\n\n<pre><code>[extensions]\nhggit = ～/Destop/hg-git/hggit/\n</code></pre>\n\n<p>另外关于 hg-git 可以参考<a href=\"http://hgtip.com/tips/advanced/2009-11-09-create-a-git-mirror/\">这里</a></p>\n\n<blockquote>\n<ul>\n<li> 建立一个github 的新的项目</li>\n<li> 从mercurial 仓库中下载需要同步到github上的仓库的代码</li>\n<li> hg pull 到github中项目地址</li>\n</ul>\n</blockquote>\n\n<p>具体代码</p>\n\n<pre><code>$ cd hg-git # (a Mercurial repository)\n$ hg bookmark -r default master # make a bookmark of master for default, so a ref gets created\n$ hg push git+ssh://git@github.com/schacon/hg-git.git\n$ hg push\n</code></pre>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/2cb20d426705ed1f3198ac4813fc7763b9c327eb/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d36656361556c742d2d3246755234424d554d5a6c47634a347a753834504e7762714f5a7259506e336374684c6c4d78622d2d32422d2d32465378576c66695338344971326447555662672d2d324238336e6c582d2d3242486d68652d2d3242327734634374446a72353831454f48\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/2cb20d426705ed1f3198ac4813fc7763b9c327eb/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d36656361556c742d2d3246755234424d554d5a6c47634a347a753834504e7762714f5a7259506e336374684c6c4d78622d2d32422d2d32465378576c66695338344971326447555662672d2d324238336e6c582d2d3242486d68652d2d3242327734634374446a72353831454f48\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>这里需要特别注意 hg-git 的目的是 服务器是git 方式管理代码。客户端是hg 方式管理代码</strong></p>\n\n<p><strong>另外这里有一篇在hg-git 上设计的hook 可以方便的pull hd 与git 写的也相当有意思</strong></p>\n\n<p><a href=\"http://morgangoose.com/blog/2010/09/29/github-and-bitbucket-hooks/\">Github and Bitbucket hooks</a></p>\n\n<p><strong>使用<a href=\"https://github.com/cosmin/git-hg\">git-hg</a>插件</strong></p>\n\n<p>这个项目与上面说的git-hg 正好相反。 这个是服务器是git 管理 客户端 是git-hg(依赖于hg) 当然客户端也可以\n是 git 管理代码</p>\n\n<pre><code> git-hg clone http://some/random/hg/repo [local-git-repo-name]\n git-hg pull # same as git-hg-fetch  git merge hg/branch_name\n</code></pre>\n\n<p>具体可以参考上面给的链接。 其中我在做ossec 的mirror时也就是使用了这种方法一次性把\nhg 的代码转换成了git的标签同时推送到github中的 在<a href=\"https://github.com/xiyoulaoyuanjia/sAoccec/tree/mirror\">这里</a></p>\n\n<p><strong>在GitHub上建立一个SVN仓库的镜像</strong></p>\n\n<p>这个的目的主要是 同步google code(svn) 到github 中的</p>\n\n<p>这个可以参考 <a href=\"http://blog.yesmeck.com/archives/create-svn-mirror-on-github/\">这里</a></p>\n\n<p>这里需要先安装git-svn </p>','/xiyoulaoyuanjia/blog/blob/master/github%20%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%85%B6%E5%AE%83%E4%BB%93%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F.md','e50413b9c0d1da120f1ae87fdf7a744b-12cbe3fb610d67318607f6510b4ef5c70f2a5463','<h1>\n<a name=\"github-\" class=\"anchor\" href=\"#github-\"><span class=\"mini-icon mini-icon-link\"></span></a>github 上建立其它仓库的镜像</h1>\n\n<p><strong>github 上面建立Mercurial 仓库代码</strong></p>\n\n<p><strong>使用 <a href=\"https://github.com/schacon/hg-git\">hg-git</a> 工具</strong></p>\n\n<p>Hg-Git是Mercurial(Hg)的扩展插件,主要功能是 本地hg版本管理git代码pull(push) 到\ngit 服务器管理代码</p>\n\n<p>上面已经说了hg-git 是hg的一个扩展插件(其实就是一些python脚本)。。那安装hg-git的方式\n就与安装hg其它的插件一样。。</p>\n\n<pre><code>[extensions]\nhggit = /path/to/hg-git\n</code></pre>\n\n<p>/path/to/hg-git 一定要指示到下载的 hg-git 的python脚本目录 例如我的脚本目录为</p>\n\n<pre><code>[extensions]\nhggit = ～/Destop/hg-git/hggit/\n</code></pre>\n\n<p>另外关于 hg-git 可以参考<a href=\"http://hgtip.com/tips/advanced/2009-11-09-create-a-git-mirror/\">这里</a></p>\n\n<blockquote>\n<ul>\n<li> 建立一个github 的新的项目</li>\n<li> 从mercurial 仓库中下载需要同步到github上的仓库的代码</li>\n<li> hg pull 到github中项目地址</li>\n</ul>\n</blockquote>\n\n<p>具体代码</p>\n\n<pre><code>$ cd hg-git # (a Mercurial repository)\n$ hg bookmark -r default master # make a bookmark of master for default, so a ref gets created\n$ hg push git+ssh://git@github.com/schacon/hg-git.git\n$ hg push\n</code></pre>'),(15,'cp命令占用双倍内存问题.md','<h1>\n<a name=\"cp\" class=\"anchor\" href=\"#cp\"><span class=\"mini-icon mini-icon-link\"></span></a>cp命令占用双倍内存问题</h1>\n\n<p><strong>使用cp命令拷贝1GB大小的文件，会占用2GB的内存</strong></p>\n\n<p>在linux下 使用cp命令拷贝东西时，会发现使用内存大小会变小 。例如下面的例子</p>\n\n<pre><code>free -m\n             total       used       free     shared    buffers     cached\nMem:          1892        117       1775          0          0         14\n-/+ buffers/cache:        103       1789\nSwap:         4095         92       4003\n</code></pre>\n\n<blockquote>\n</blockquote>\n\n<pre><code>time cp tmp /mnt/raid-data/\n\nreal    0m9.278s\nuser    0m0.009s\nsys     0m1.468s\n</code></pre>\n\n<blockquote>\n</blockquote>\n\n<pre><code>free -m\n             total       used       free     shared    buffers     cached\nMem:          1892       1663        229          0        512       1038\n-/+ buffers/cache:        112       1780\nSwap:         4095         92       4003\n</code></pre>\n\n<p>cp前后，used内存从117MB变成啦1663MB。。。 cp 前后Mem内存变小了。内存没有释放吗？\n这是一个普遍错误的观点。。      available memory=free+buffers+cached 也就是说 可用\n内存 是 free -m 的第二行。而不是第一行。。。</p>\n\n<p>那么linux为什么要这样子做呢？</p>\n\n<p>cp 命令将文件从一个地方读取出来，又写到另一部分去，所以只要还有闲着的内\n存，Linux 内核就会将这两份数据放在内存中，使得内存中有效数据量增加两个所\n复制文件的大小。</p>\n\n<p>如果真是这样子的话，那么是不是缓存一份就好了，为什么要留两份呢？</p>\n\n<p>不过内核不知道源文件和目标文件一样，所以两份都会保存\n当你读源文件时，内核就把源文件给缓存了。当你写目标文件的时候，系统顺便把目标文件缓存下来了。\n嗯，其实一份就够了。不过内核不知道源文件和目标文件一样，所以两份都会保存。</p>\n\n<p>为什么这样设计呢？\n当你读过或写过一次文件后，如果缓存起来，下次用的时候就不用从硬盘里读取了，速度会快很多。反正内存闲着也是闲着，没好处。</p>\n\n<p>至于如果有程序需要大量内存，必须释放缓存的文件的话，其实开销很小的。内存释放的时候，只是说一声某段内存可以用了而已，并没有真的给那段内存清零啊，下次写上去的时候直接覆盖就行了。\n就像以前的磁带录音机，一盘磁带的内容你如果不要了，你只是简单的把那盘带子标记为“空”，下次录东西就直接覆盖上去了，你不会专门录一整盘带子的无声进去的。</p>\n\n<p>使用200MB cache与1GB cache，为什么速度没有差别？\n不管你有多少缓存，读写的速度还是受限与磁盘IO。反正，你一共要读500MB数据，要写500MB数据，\n花的时间就是这点了。区别在于，你要是再拷贝一份文件，就可以省去读的那500MB。\n我的实验：一个1G左右大文件，移动硬盘（本机SSD太快了，不方便计时）cp source target1 \n花费了1分10秒，再次执行cp source target2  花费了35秒。验证了刚才说的，\n第二次复制的时候不必再读了。\ncp文件毕竟是少数情况。多数情况如你打开一个程序；或者编辑一个文件，存盘后一会儿再打开；\n或者你的机器做ftp服务器；或者bt上传做种，这种机制的好处就很明显了。</p>\n\n<p>一般看free，都是要看第二行的，不算Cache。Cache的内存其实不能算被占用的——Windows里也有cache\n，但是你用任务管理器，它都不告诉你Cache了多少，直接把free+cache显示给你当做空闲内存。</p>','/xiyoulaoyuanjia/blog/blob/master/cp%E5%91%BD%E4%BB%A4%E5%8D%A0%E7%94%A8%E5%8F%8C%E5%80%8D%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98.md','1e90c15d06d6b538efea8525c95bde70-e13f20a8d03be489ee46339fec801817aa297406','<h1>\n<a name=\"cp\" class=\"anchor\" href=\"#cp\"><span class=\"mini-icon mini-icon-link\"></span></a>cp命令占用双倍内存问题</h1>\n\n<p><strong>使用cp命令拷贝1GB大小的文件，会占用2GB的内存</strong></p>\n\n<p>在linux下 使用cp命令拷贝东西时，会发现使用内存大小会变小 。例如下面的例子</p>\n\n<pre><code>free -m\n             total       used       free     shared    buffers     cached\nMem:          1892        117       1775          0          0         14\n-/+ buffers/cache:        103       1789\nSwap:         4095         92       4003\n</code></pre>\n\n<blockquote>\n</blockquote>\n\n<pre><code>time cp tmp /mnt/raid-data/\n\nreal    0m9.278s\nuser    0m0.009s\nsys     0m1.468s\n</code></pre>\n\n<blockquote>\n</blockquote>\n\n<pre><code>free -m\n             total       used       free     shared    buffers     cached\nMem:          1892       1663        229          0        512       1038\n-/+ buffers/cache:        112       1780\nSwap:         4095         92       4003\n</code></pre>\n\n<p>cp前后，used内存从117MB变成啦1663MB。。。 cp 前后Mem内存变小了。内存没有释放吗？\n这是一个普遍错误的观点。。      available memory=free+buffers+cached 也就是说 可用\n内存 是 free -m 的第二行。而不是第一行。。。</p>\n\n<p>那么linux为什么要这样子做呢？</p>\n\n<p>cp 命令将文件从一个地方读取出来，又写到另一部分去，所以只要还有闲着的内\n存，Linux 内核就会将这两份数据放在内存中，使得内存中有效数据量增加两个所\n复制文件的大小。</p>\n\n<p>如果真是这样子的话，那么是不是缓存一份就好了，为什么要留两份呢？</p>\n\n<p>不过内核不知道源文件和目标文件一样，所以两份都会保存\n当你读源文件时，内核就把源文件给缓存了。当你写目标文件的时候，系统顺便把目标文件缓存下来了。\n嗯，其实一份就够了。不过内核不知道源文件和目标文件一样，所以两份都会保存。</p>\n\n<p>为什么这样设计呢？\n当你读过或写过一次文件后，如果缓存起来，下次用的时候就不用从硬盘里读取了，速度会快很多。反正内存闲着也是闲着，没好处。</p>\n\n<p>至于如果有程序需要大量内存，必须释放缓存的文件的话，其实开销很小的。内存释放的时候，只是说一声某段内存可以用了而已，并没有真的给那段内存清零啊，下次写上去的时候直接覆盖就行了。\n就像以前的磁带录音机，一盘磁带的内容你如果不要了，你只是简单的把那盘带子标记为“空”，下次录东西就直接覆盖上去了，你不会专门录一整盘带子的无声进去的。</p>\n\n<p>使用200MB cache与1GB cache，为什么速度没有差别？\n不管你有多少缓存，读写的速度还是受限与磁盘IO。反正，你一共要读500MB数据，要写500MB数据，\n花的时间就是这点了。区别在于，你要是再拷贝一份文件，就可以省去读的那500MB。\n我的实验：一个1G左右大文件，移动硬盘（本机SSD太快了，不方便计时）cp source target1 \n花费了1分10秒，再次执行cp source target2  花费了35秒。验证了刚才说的，\n第二次复制的时候不必再读了。\ncp文件毕竟是少数情况。多数情况如你打开一个程序；或者编辑一个文件，存盘后一会儿再打开；\n或者你的机器做ftp服务器；或者bt上传做种，这种机制的好处就很明显了。</p>\n\n<p>一般看free，都是要看第二行的，不算Cache。Cache的内存其实不能算被占用的——Windows里也有cache\n，但是你用任务管理器，它都不告诉你Cache了多少，直接把free+cache显示给你当做空闲内存。</p>'),(16,'JSON .md','<h1>\n<a name=\"json\" class=\"anchor\" href=\"#json\"><span class=\"mini-icon mini-icon-link\"></span></a>JSON</h1>\n\n<p><strong>note</strong>:参考<a href=\"http://json.org/json-zh.html\">json官网</a></p>\n\n<p><strong>json常用的两种结构:</strong></p>\n\n<blockquote>\n<ul>\n<li><p>名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</p></li>\n<li><p>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</p></li>\n</ul>\n</blockquote>\n\n<hr><p><strong>json常用数据格式</strong></p>\n\n<ul>\n<li>对象: </li>\n</ul><blockquote>\n<p>对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。</p>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/7d7e10e82155bda95abc5bb439d4e5719a5bfdff/687474703a2f2f6a736f6e2e6f72672f6f626a6563742e676966\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/7d7e10e82155bda95abc5bb439d4e5719a5bfdff/687474703a2f2f6a736f6e2e6f72672f6f626a6563742e676966\" alt=\"object\" style=\"max-width:100%;\"></a></p>\n\n<ul>\n<li>数组:</li>\n</ul><blockquote>\n<p>数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。</p>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/217d7282f8725d0b496331e3d5c47bcc8216aad4/687474703a2f2f6a736f6e2e6f72672f61727261792e676966\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/217d7282f8725d0b496331e3d5c47bcc8216aad4/687474703a2f2f6a736f6e2e6f72672f61727261792e676966\" alt=\"array\" style=\"max-width:100%;\"></a></p>\n\n<ul>\n<li>值:\n值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。</li>\n</ul><p><a href=\"https://a248.e.akamai.net/camo.github.com/fd759b7968d950435c5fed705ff3a64dab343f62/687474703a2f2f6a736f6e2e6f72672f76616c75652e676966\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/fd759b7968d950435c5fed705ff3a64dab343f62/687474703a2f2f6a736f6e2e6f72672f76616c75652e676966\" alt=\"value\" style=\"max-width:100%;\"></a></p>\n\n<ul>\n<li>字符串:</li>\n</ul><blockquote>\n<p>字符串（string）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。</p>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/2c266c9f54b3946e8864078811d51757320ab244/687474703a2f2f6a736f6e2e6f72672f737472696e672e676966\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/2c266c9f54b3946e8864078811d51757320ab244/687474703a2f2f6a736f6e2e6f72672f737472696e672e676966\" alt=\"string\" style=\"max-width:100%;\"></a></p>\n\n<hr><p><strong>python对json的处理</strong></p>\n\n<blockquote>\n<ul>\n<li>对简单数据类型的encoding 和 decoding：使用json的dumps方法对python的数据进行编码.也就是把python的数据类型转换成json的数据类型</li>\n</ul>\n</blockquote>\n\n<pre><code>import json\nobj = [[1,2,3],123,123.123,\'abc\',{\'key1\':(1,2,3),\'key2\':(4,5,6)}]\nencodedjson = json.dumps(obj)\nprint repr(obj)\nprint encodedjson\n</code></pre>\n\n<p><em>note</em>  repr函数与str的区别</p>\n\n<p>以上的输出结果为</p>\n\n<pre><code>[[1, 2, 3], 123, 123.123, \'abc\', {\'key2\': (4, 5, 6), \'key1\': (1, 2, 3)}] \n[[1, 2, 3], 123, 123.123, \"abc\", {\"key2\": [4, 5, 6], \"key1\": [1, 2, 3]}]\n</code></pre>\n\n<p>在python的编码过程中会从原始结构向json的结构转化\n<a href=\"https://a248.e.akamai.net/camo.github.com/1b2ddd903030156fa9fa8df5416ab38989e68c33/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f636f7365722f3230313131322f3230313131323134313632313133363238372e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/1b2ddd903030156fa9fa8df5416ab38989e68c33/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f636f7365722f3230313131322f3230313131323134313632313133363238372e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>相反的处理过程使用json.loads()函数</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/b5ee4ddbfe15e73fbf077dce51adbb1f06807c26/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f636f7365722f3230313131322f3230313131323134313632313134363137382e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/b5ee4ddbfe15e73fbf077dce51adbb1f06807c26/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f636f7365722f3230313131322f3230313131323134313632313134363137382e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>json对自定义对象的操作</strong></p>\n\n<blockquote>\n<p>python 数据结构到JSON的转换可以看出 必须把把python的对象转化成可以转化到python的数据格式.当然这里有两种方法可以考虑 一种继承，一种自己定义转化函数\n<a href=\"http://huacnlee.com/blog/convert-python-object-to-jason/\">参考这里</a></p>\n</blockquote>\n\n<pre><code>def obj2dict(obj):\n\"\"\"\nsummary:\n    将object转换成dict类型\n\"\"\"\nmemberlist = [m for m in dir(obj)]\n_dict = {}\nfor m in memberlist:\n    if m[0] != \"_\" and not callable(m):\n        _dict[m] = getattr(obj,m)\n\nreturn _dict\nreturn simplejson.encode(str(obj2dict(self)))\n</code></pre>','/xiyoulaoyuanjia/blog/blob/master/JSON%20.md','22cd99294dd3f24a40fa3008a24a7ead-27ce5e36995db72e2b8fbb46f063bda241014a43','<h1>\n<a name=\"json\" class=\"anchor\" href=\"#json\"><span class=\"mini-icon mini-icon-link\"></span></a>JSON</h1>\n\n<p><strong>note</strong>:参考<a href=\"http://json.org/json-zh.html\">json官网</a></p>\n\n<p><strong>json常用的两种结构:</strong></p>\n\n<blockquote>\n<ul>\n<li><p>名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</p></li>\n<li><p>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</p></li>\n</ul>\n</blockquote>'),(17,'README.md','<h1>\n<a name=\"blog\" class=\"anchor\" href=\"#blog\"><span class=\"mini-icon mini-icon-link\"></span></a>blog</h1>\n\n<p>读书笔记与总结</p>\n\n<p>most blogs of <a href=\"http://www.xiyoulaoyuanjia.com\">www.xiyoulaoyuanjia.com</a>  is here </p>\n\n<p>you can get it from gh-pages branch</p>\n\n<p>the others are <a href=\"https://github.com/xiyoulaoyuanjia/blog/wiki/_pages\">here</a></p>','/xiyoulaoyuanjia/blog/blob/master/README.md','04c6e90faac2675aa89e2176d2eec7d8-5f2e549ff0fffb5ff3e53aa1a00e8dc16eb97ab8','<h1>\n<a name=\"blog\" class=\"anchor\" href=\"#blog\"><span class=\"mini-icon mini-icon-link\"></span></a>blog</h1>\n\n<p>读书笔记与总结</p>\n\n<p>most blogs of <a href=\"http://www.xiyoulaoyuanjia.com\">www.xiyoulaoyuanjia.com</a>  is here </p>\n\n<p>you can get it from gh-pages branch</p>\n\n<p>the others are <a href=\"https://github.com/xiyoulaoyuanjia/blog/wiki/_pages\">here</a></p>'),(18,'理解python中的元类.md','<h1>\n<a name=\"python\" class=\"anchor\" href=\"#python\"><span class=\"mini-icon mini-icon-link\"></span></a>理解python中的元类</h1>\n\n<p><a href=\"http://blog.jobbole.com/21351/\">note:参考这里</a></p>\n\n<p><strong>类也是对象</strong></p>\n\n<p>一般而言类是描述如何生成对象的代码断。但是python中的类还远不止此,只有使用new关键字。python就生成了对象</p>\n\n<pre><code> class ObjectCreator(object):\n…       pass\n…\n</code></pre>\n\n<p>则此时在内存中创建了一个对象.这个对象的名称为ObjectCreator。也就是说它拥有对象的特征。</p>\n\n<ol>\n<li>可以将它赋值给变量</li>\n<li>可以拷贝它</li>\n<li>可以增加属性</li>\n<li>可以作为参数传递</li>\n</ol><p><strong>动态地创建类</strong></p>\n\n<p>这里注意因为类是对象,所以可以在运行的时候动态的创建</p>\n\n<pre><code> def choose_class(name):\n…       if name == \'foo\':\n…           class Foo(object):\n…               pass\n…           return Foo     # 返回的是类，不是类的实例\n…       else:\n…           class Bar(object):\n…               pass\n…           return Bar\n…\n</code></pre>\n\n<p>type 在动态生成对象的使用。可以接受一个类的描述返回一个类。使用格式为 </p>\n\n<p>type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p>\n\n<pre><code> MyShinyClass = type(\'MyShinyClass\', (), {})  # 返回一个类对象\n print MyShinyClass\nclass \'__main__.MyShinyClass\'\n print MyShinyClass()  #  创建一个该类的实例\n__main__.MyShinyClass object at 0x8997cec\n</code></pre>\n\n<p>这里需要重点知道动态的为类增加方法</p>\n\n<pre><code> def echo_bar(self):\n…       print self.bar\n…\n FooChild = type(\'FooChild\', (Foo,), {\'echo_bar\': echo_bar})\n hasattr(Foo, \'echo_bar\')\nFalse\n hasattr(FooChild, \'echo_bar\')\nTrue\n my_foo = FooChild()\n my_foo.echo_bar()\nTrue\n</code></pre>\n\n<p>从上面可以看出可以动态的创建类.当然上面其实是new关键字幕后所作的事情</p>\n\n<p><strong><em>什么是元类</em></strong></p>\n\n<p>元类是用来创建类的东西。元类就是类的类</p>\n\n<p>注意 所有东西（整型，字符串、函数、类）都是对象</p>\n\n<pre><code> age = 35\n age.__class__\ntype \'int\'\n name = \'bob\'\n name.__class__\ntype \'str\'\n def foo(): pass\nfoo.__class__\ntype \'function\'\n class Bar(object): pass\n b = Bar()\n b.__class__\nclass \'__main__.Bar\'\n</code></pre>\n\n<p>当然这里有一个很有意思的问题__class__的__class__是什么呢？</p>\n\n<pre><code> a.__class__.__class__\ntype \'type\'\n age.__class__.__class__\ntype \'type\'\n foo.__class__.__class__\ntype \'type\'\n b.__class__.__class__\ntype \'type\'\n</code></pre>\n\n<p>所以元类就是用来创建类这种东西的类了</p>\n\n<pre><code>class Foo(Bar):\n    pass\n</code></pre>\n\n<p>python分析的步骤为</p>\n\n<ol>\n<li>Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。</li>\n<li>如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。</li>\n</ol><p><strong><em>自定义元类</em></strong></p>\n\n<pre><code> 元类会自动将你通常传给‘type’的参数作为自己的参数传入\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n    \'\'\'返回一个类对象，将属性都转为大写形式\'\'\'\n    #  选择所有不以\'__\'开头的属性\n    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(\'__\'))\n # 将它们转为大写形式\n    uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n    # 通过\'type\'来做类对象的创建\n    return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr  #  这会作用到这个模块中的所有类\n\nclass Foo(object):\n    # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中\n    bar = \'bip\'\n</code></pre>\n\n<p>上面很重要的一点是_作用范围_</p>\n\n<p><strong><em>结语</em></strong></p>\n\n<p>python中一切都是实例。要么是类的实例。要么是元类的实例.当然除了type。当然一般修改类还是使用以下两种方法</p>\n\n<blockquote>\n<ul>\n<li>Monkey patching</li>\n<li>class decorators</li>\n</ul>\n</blockquote>\n\n<p>ps <a href=\"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python\">参考这里</a></p>','/xiyoulaoyuanjia/blog/blob/master/%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB.md','5ccf0a8d85ccdfe5d2904e19db5c3380-4407f3bd8a4cc06d9a57f4c3a382317d26c4713c','<h1>\n<a name=\"python\" class=\"anchor\" href=\"#python\"><span class=\"mini-icon mini-icon-link\"></span></a>理解python中的元类</h1>\n\n<p><a href=\"http://blog.jobbole.com/21351/\">note:参考这里</a></p>\n\n<p><strong>类也是对象</strong></p>\n\n<p>一般而言类是描述如何生成对象的代码断。但是python中的类还远不止此,只有使用new关键字。python就生成了对象</p>\n\n<pre><code> class ObjectCreator(object):\n…       pass\n…\n</code></pre>\n\n<p>则此时在内存中创建了一个对象.这个对象的名称为ObjectCreator。也就是说它拥有对象的特征。</p>\n\n<ol>\n<li>可以将它赋值给变量</li>\n<li>可以拷贝它</li>\n<li>可以增加属性</li>\n<li>可以作为参数传递</li>\n</ol><p><strong>动态地创建类</strong></p>\n\n<p>这里注意因为类是对象,所以可以在运行的时候动态的创建</p>\n\n<pre><code> def choose_class(name):\n…       if name == \'foo\':\n…           class Foo(object):\n…               pass\n…           return Foo     # 返回的是类，不是类的实例\n…       else:\n…           class Bar(object):\n…               pass\n…           return Bar\n…\n</code></pre>\n\n<p>type 在动态生成对象的使用。可以接受一个类的描述返回一个类。使用格式为 </p>\n\n<p>type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p>\n\n<pre><code> MyShinyClass = type(\'MyShinyClass\', (), {})  # 返回一个类对象\n print MyShinyClass\nclass \'__main__.MyShinyClass\'\n print MyShinyClass()  #  创建一个该类的实例\n__main__.MyShinyClass object at 0x8997cec\n</code></pre>\n\n<p>这里需要重点知道动态的为类增加方法</p>\n\n<pre><code> def echo_bar(self):\n…       print self.bar\n…\n FooChild = type(\'FooChild\', (Foo,), {\'echo_bar\': echo_bar})\n hasattr(Foo, \'echo_bar\')\nFalse\n hasattr(FooChild, \'echo_bar\')\nTrue\n my_foo = FooChild()\n my_foo.echo_bar()\nTrue\n</code></pre>\n\n<p>从上面可以看出可以动态的创建类.当然上面其实是new关键字幕后所作的事情</p>\n\n<p><strong><em>什么是元类</em></strong></p>\n\n<p>元类是用来创建类的东西。元类就是类的类</p>\n\n<p>注意 所有东西（整型，字符串、函数、类）都是对象</p>\n\n<pre><code> age = 35\n age.__class__\ntype \'int\'\n name = \'bob\'\n name.__class__\ntype \'str\'\n def foo(): pass\nfoo.__class__\ntype \'function\'\n class Bar(object): pass\n b = Bar()\n b.__class__\nclass \'__main__.Bar\'\n</code></pre>\n\n<p>当然这里有一个很有意思的问题__class__的__class__是什么呢？</p>\n\n<pre><code> a.__class__.__class__\ntype \'type\'\n age.__class__.__class__\ntype \'type\'\n foo.__class__.__class__\ntype \'type\'\n b.__class__.__class__\ntype \'type\'\n</code></pre>\n\n<p>所以元类就是用来创建类这种东西的类了</p>\n\n<pre><code>class Foo(Bar):\n    pass\n</code></pre>\n\n<p>python分析的步骤为</p>\n\n<ol>\n<li>Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。</li>\n<li>如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。</li>\n</ol><p><strong><em>自定义元类</em></strong></p>\n\n<pre><code> 元类会自动将你通常传给‘type’的参数作为自己的参数传入\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n    \'\'\'返回一个类对象，将属性都转为大写形式\'\'\'\n    #  选择所有不以\'__\'开头的属性\n    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(\'__\'))\n # 将它们转为大写形式\n    uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n    # 通过\'type\'来做类对象的创建\n    return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr  #  这会作用到这个模块中的所有类\n\nclass Foo(object):\n    # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中\n    bar = \'bip\'\n</code></pre>\n\n<p>上面很重要的一点是_作用范围_</p>\n\n<p><strong><em>结语</em></strong></p>\n\n<p>python中一切都是实例。要么是类的实例。要么是元类的实例.当然除了type。当然一般修改类还是使用以下两种方法</p>\n\n<blockquote>\n<ul>\n<li>Monkey patching</li>\n<li>class decorators</li>\n</ul>\n</blockquote>\n\n<p>ps <a href=\"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python\">参考这里</a></p>'),(19,'linux下的同步 异步 阻塞 非阻塞.md','<p><strong>linux 下io</strong></p>\n\n<p><strong>关于IO的同步,异步,阻塞,非阻塞</strong></p>\n\n<blockquote>\n<ul>\n<li>一般典型的I/O(同步阻塞I/O)</li>\n</ul>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/13268dbf9fe65bbab17d693d2a3c06d7c4839506/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d3331633168472d2d32426a5435456c43744461414c71664b6e397153472d2d324271426a776e30344f70777463704858773044664f66744a33614353497a49526a744f4d485a5a4d6c4464624631776539334249696f63767275782d2d324663314d4d4446\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/13268dbf9fe65bbab17d693d2a3c06d7c4839506/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d3331633168472d2d32426a5435456c43744461414c71664b6e397153472d2d324271426a776e30344f70777463704858773044664f66744a33614353497a49526a744f4d485a5a4d6c4464624631776539334249696f63767275782d2d324663314d4d4446\" alt=\"\" style=\"max-width:100%;\"></a>\n从应用程序的角度来说，read 调用可能会延续很长时间。实际上，在内核执行读操作和其他工作时，\n应用程序的确会被阻塞，也就是说应用程序不能做其它事情了。</p>\n\n<blockquote>\n<ul>\n<li> 同步 非阻塞I/O</li>\n</ul>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/249c1f81d280893147dc47603193aeda2dea3786/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6562656178586a41316e5a45464b77474173333756767442432d2d32464768657a6c36732d2d3246523072764751796f3134385a6f6e2d2d32464337326f6263757a6b6d6d784941753539576659573854517a464537314767766b6733736630317a633379\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/249c1f81d280893147dc47603193aeda2dea3786/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6562656178586a41316e5a45464b77474173333756767442432d2d32464768657a6c36732d2d3246523072764751796f3134385a6f6e2d2d32464337326f6263757a6b6d6d784941753539576659573854517a464537314767766b6733736630317a633379\" alt=\"\" style=\"max-width:100%;\"></a>\n实际上，该方式需要应用程序以一种轮询的方式来实现数据读取，多次无谓的系统调用会加大系统开销，影响应整个系统的吞吐量。\n这种需要多次的用户进程与内核进程切换。。</p>\n\n<blockquote>\n<ul>\n<li> select poll epoll 方式。。。 </li>\n</ul>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/a2eb9878127c147844b26dcbeed5dbdb52c09a2f/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d3530353866625730475a4c7243725359614e7a55443357736b674b68645864702d2d324276452d2d32466e7a30776533794d6841444930673976626b70675a736b5034382d2d32424a4a31426868684a4676524d4b7675516c52505279362d2d32425a3562362d2d32464f\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/a2eb9878127c147844b26dcbeed5dbdb52c09a2f/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d3530353866625730475a4c7243725359614e7a55443357736b674b68645864702d2d324276452d2d32466e7a30776533794d6841444930673976626b70675a736b5034382d2d32424a4a31426868684a4676524d4b7675516c52505279362d2d32425a3562362d2d32464f\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>该方式中，select(或poll)的调用仍然会阻塞进程，与一般典型的I/O不一样的它是等待事件通知。但是它引入了超时机制，可以让应用程序有权力避免过长时间等待；\n另一方面，如果应用程序需要读写多个文件，该方式可以一显身手。</p>\n\n<blockquote>\n<ul>\n<li>异步I/O</li>\n</ul>\n</blockquote>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/6efed2734d1b9dd4322be5d2d087ed92e826e061/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d34653234544b516367626976635a70626739707331636873635442365573572d2d3246326b4852346f4a64325376772d2d32424c716a453368314a716755383373783045616c773366344c4c4b50597431526e6f644665694968434434753639456d\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/6efed2734d1b9dd4322be5d2d087ed92e826e061/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d34653234544b516367626976635a70626739707331636873635442365573572d2d3246326b4852346f4a64325376772d2d32424c716a453368314a716755383373783045616c773366344c4c4b50597431526e6f644665694968434434753639456d\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>IO 常见的几种模型</strong></p>\n\n<blockquote>\n<ul>\n<li>阻塞型 IO(blocking I/O)</li>\n<li>非阻塞性IO(nonblocking I/O)</li>\n<li>IO多路复用(I/O multiplexing)</li>\n<li>信号驱动IO(signal driven I/O)</li>\n<li>异步IO(asynchronous I/O)</li>\n</ul>\n</blockquote>\n\n<p><strong>IO 操作可以分为两个阶段</strong></p>\n\n<blockquote>\n<ul>\n<li>等待数据准备好</li>\n<li>将数据从内核缓冲区复制到用户进程缓冲区</li>\n</ul>\n</blockquote>\n\n<p><strong>同步与异步的区别</strong></p>\n\n<blockquote>\n<ul>\n<li>同步IO，需要用户进程主动将存放在内核缓冲区中的数据拷贝到用户进程中。</li>\n<li><p>异步IO，内核会自动将数据从内核缓冲区拷贝到用户缓冲区，然后再通知用户。</p></li>\n<li><p>io 多路复用</p></li>\n</ul>\n</blockquote>\n\n<p>当对多路复用IO进行调用时，比如使用poll。需注意的是，poll是系统调用，当调用poll的时候，其实已经是陷入了内核，是内核线程在跑了。因此对于调用poll的用户进程来讲，此时是阻塞的。\n因为poll的底层实现，是去扫描每个文件描述符(fd)，而如果要对感兴趣的fd进行扫描，那么只能将每个描述符设置成非阻塞的形式(对于用户进程来讲，设置fd是阻塞还是非阻塞，可以使用系统调用fcntl)，这样才有可能进行扫描。如果扫描当中，发现有可读(如果可读是用户感兴趣的)的fd，那么select就在用户进程层面就会返回，并且告知用户进程哪些fd是可读的。\n这时候，用户进程仍然需要使用read的系统调用，将fd的数据，从内核缓冲区拷贝到用户进程缓冲区(这也是poll为同步IO的原因)。\n那么此时的read是阻塞还是非阻塞呢？这就要看fd的状态了，如果fd被设置成了非阻塞，那么此时的read就是非阻塞的；如果fd被设置成了阻塞，那么此时的read就是阻塞的。\n不过程序已经执行到了这时候，不管fd是阻塞还是非阻塞，都没有任何区别，因为之前的poll，就是知道有数据准备好了才返回的，也就是说内核缓冲区已经有了数据，此时进行read，是肯定能够将数据拷贝到用户进程缓冲区的。</p>','/xiyoulaoyuanjia/blog/blob/master/linux%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%20%E5%BC%82%E6%AD%A5%20%E9%98%BB%E5%A1%9E%20%E9%9D%9E%E9%98%BB%E5%A1%9E.md','43834cc8d6fda68977259a67d0a8a3b9-a04f43d957746c04ff9f50f612a651cb82e2d35b','<p><strong>linux 下io</strong></p>\n\n<p><strong>关于IO的同步,异步,阻塞,非阻塞</strong></p>\n\n<blockquote>\n<ul>\n<li>一般典型的I/O(同步阻塞I/O)</li>\n</ul>\n</blockquote>'),(20,'linux使用记录.md','<h1>\n<a name=\"linux\" class=\"anchor\" href=\"#linux\"><span class=\"mini-icon mini-icon-link\"></span></a>linux使用记录</h1>\n\n<hr><p><strong>fedora 17 kde</strong></p>\n\n<p><strong><em>关于konsole光标前面空格的问题</em></strong></p>\n\n<p>出现这种问题的原因是之前更高字体造成的 删除~/.fonts 下的字体即可</p>\n\n<p><strong><em>Fedora 17 安装 Cinnamon 桌面环境</em></strong></p>\n\n<p>cinnamon桌面环境是linux Mint 下的桌面环境 当然fedora 17 下也是可以安装的</p>\n\n<pre><code>sudo curl http://repos.fedorapeople.org/repos/leigh123linux/cinnamon/fedora-cinnamon.repo -o /etc/yum.repos.d/fedora-cinnamon.repo\nsudo yum install cinnamon\n</code></pre>\n\n<p>注销后登陆选择 cinnamon即可</p>\n\n<p><strong><em><a href=\"http://forums.fedoraforum.org/showthread.php?t=276286\">Fedora 17 使用MATE桌面</a></em></strong></p>\n\n<p>MATE 是传统gnome2的一个分支。代码维护在github上</p>\n\n<pre><code>yum install https://dl.dropbox.com/u/49862637/Mate-desktop/fedora_17/mate-desktop-fedora-updates/noarch/mate-desktop-release-17-4.fc17.noarch.rpm\nyum groupinstall MATE-Desktop\n</code></pre>\n\n<p><strong><em>yum groupinstall</em></strong>    </p>\n\n<p>一般而言 yum 可以使用 intall 与 groupinstall 安装软件。install安装单个软件以及单个软件的依赖。而groupinstall 可以理解为打包安装许多软件以及这些软件的依赖</p>\n\n<p>例如安装mysql</p>\n\n<pre><code>yum install mysql\nyum groupinstall \"MySQL Database\"\n\nGroup: MySQL Database\n Description: This package group contains packages useful for use with MySQL.\n Mandatory Packages:\n mysql\n Default Packages:\n unixODBC\n mysql-server\n MySQL-python\n mysql-connector-odbc\n libdbi-dbd-mysql\n perl-DBD-MySQL\n Optional Packages:\n mod_auth_mysql\n mysql-devel\n qt-MySQL\n mysql-bench\n php-mysql\n</code></pre>\n\n<p>由上面可以看出yum groupinstall 这种安装方式 会安装多个软件。以及自动解决安装包的依赖问题</p>\n\n<p><strong>alsa-lib-1.0.26-1.fc17.i686 与 alsa-lib-1.0.25-3.fc17.x86_64 冲突</strong></p>\n\n<p>今天在安装teamview时，官方在redhat系里面没有给出64位对应的安装包.其安装版本依赖许多32位的包，上面就是其中一个。无奈不能正常安装</p>\n\n<p>这里使用先删除x64的包，然后在安装alsa-lib-1.0.26-1.fc17.i686 经验证成功安装</p>\n\n<p><strong>centos 常见的3个第三方源</strong></p>\n\n<p>EPEL RPMForge RPMFusion</p>\n\n<p><strong>linux ～用来表示 home目录</strong></p>\n\n<p>原因是80(1970s)年代 ,Lear-Siegler 生产的 ADM-3A 终端所用的键盘把～与home键在一起 </p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/6a09a9bfc45b6648d36fe8388bfc3a695eb57b77/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f612f61302f4b425f5465726d696e616c5f41444d33412e737667\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/6a09a9bfc45b6648d36fe8388bfc3a695eb57b77/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f612f61302f4b425f5465726d696e616c5f41444d33412e737667\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/7e5f6474d0e3bef0dbdb7f8f8b16305869d4eed7/687474703a2f2f692e737461636b2e696d6775722e636f6d2f4c336573762e6a7067\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/7e5f6474d0e3bef0dbdb7f8f8b16305869d4eed7/687474703a2f2f692e737461636b2e696d6775722e636f6d2f4c336573762e6a7067\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p><strong>shell脚本罗列出所有名称中含有中文的文件和目录，并统计一下总数</strong></p>\n\n<p>find . -type f | grep -P -r \"[\\x80-\\xFF]\" | cat | wc -l</p>\n\n<p><strong>Waiting for network configuration--ubuntu 11.10 解决方案</strong></p>\n\n<p>打开本机 进入11.04 系统(后升级到11.10) </p>\n\n<p>首先是提示 waiting for the network configuration</p>\n\n<p>然后是 Waiting for 60 seconds more for network configuration</p>\n\n<p>最后是 booting system without full network configuration...</p>\n\n<p>很是郁闷 最后 sudo vim /etc/network/interface 进入 修改配置文件 为</p>\n\n<pre><code>auto lo\niface lo inet loopback\n#auto eth0\n#iface eth0 inet dhcp\n</code></pre>\n\n<p>也就是注释掉 eth0 的网卡配置  开机速度飞快。。</p>\n\n<p><strong>操作含有---- 名的文件</strong></p>\n\n<p>--是标准的去掉-特殊含义的方式。比如说touch -- ----就可以创建一个文件名为----的文件\n例如删掉----名的文件\n    rm -- ----</p>\n\n<p><strong>top里面可以只列出某个名字的进程</strong></p>\n\n<p>top  -p 后根需要列出得到pid的值</p>\n\n<p>top -p $(pgrep -d\',\' http)这个分为1.寻找含有http字符的进程名称的pid(注意pgrep的用法 -d表示结果用逗号区分)\"$()\"这种用法把结果直接拿来用需要学习</p>\n\n<p>下面还有一个小例子</p>\n\n<p>例：mysqld的信息</p>\n\n<p>(1)得到mysqld进程的pid</p>\n\n<pre><code>[root@6 ~]# pidof mysqld\n21538\n</code></pre>\n\n<p>(2)top指定查看PID</p>\n\n<pre><code>[root@6 ~]# top -p 21538\n</code></pre>\n\n<p><strong>ACPI: [Package] has zero elements</strong></p>\n\n<p>华硕k52d 本本 上装得 fedora 17  64位  每一次启动都会出现 \nACPI: [Package] has zero elements \n然后有时可以顺利的进入系统有时停在此处 不知怎么解决。。</p>\n\n<p>解决办法: </p>\n\n<blockquote>\n<p>*1.在 /etc/default/grub 修改如下\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=\"Fedora\"\nGRUB_DEFAULT=saved\nGRUB_CMDLINE_LINUX=\" nomodeset rd.md=0 rd.lvm=0 rd.dm=0 SYSFONT=True  KEYTABLE=us rd.luks=0 LANG=en_US.UTF-8 rhgb quiet acpi=off\"</p>\n\n<p>*2.grub2-mkconfig -o /boot/grub2/grub.cfg</p>\n</blockquote>\n\n<p><em>这里需要注意acpi必须为小写。之前一直大写搞了半天。。</em></p>\n\n<p><strong>cannot open font file ture</strong></p>\n\n<p>fedora 17 上的错误修改如下</p>\n\n<pre><code>vi /etc/default/grub \nSYSFONT=True改掉就好 SYSFONT=latarcyrheb-sun16\ngrub2-mkconfig -o /boot/grub2/grub.cfg\n</code></pre>\n\n<p><em>查看安装软件的信息 包括时间包、依赖的包等信息</em>**</p>\n\n<pre><code>yum history list\nyum history info 123\nyum history undo 123\n</code></pre>\n\n<p><strong>linux系统剪贴板</strong></p>\n\n<p>linux 系统存在两个剪贴板  一个叫做选择缓冲区(X11 selection buffer)   另一个叫做剪切板(clipboard)</p>\n\n<p>选择缓冲区是实时的，当使用鼠标选择内容时。即将内容复制到了选择缓冲区中。 剪贴板同 windows下的剪贴版。。</p>\n\n<p>另外需要xterm复制用的是**选择缓冲区** 当然现在还用这个的实在比较少了。。 鼠标中间的按钮一般是选择缓冲区或者shift+Insert</p>\n\n<p><strong>Fedora中的kmod与akmod</strong></p>\n\n<p>由于许可证或使用规模等原因，一些硬件的驱动无法进入kernel，只能通过内核模块的形式来加载使用。在Fedora中如果你启用了rpmfusion-nonfree源，你会看到大量kmod-打头的软件包，大多都是rpmfusion帮我们编译、打包好的各类私有驱动（比如nvidia、ati的显卡驱动，broadcom的网卡驱动等等） </p>\n\n<p><strong>Fedora中的kmod与akmod区别</strong></p>\n\n<p>akmod**没有子包，而kmod**则有大量的子包akmod替代kmod是大势所趋</p>\n\n<p><strong>每次开机都会出现 Enter password for default keyring to unlock?    然后要求输入密码？甚是烦躁。。</strong></p>\n\n<p>解决办法。。 Right-click on the NetworkManager icon on your panel and select edit connections. Click the Wireless tab and select your network. Click Edit and tick the checkbox on the bottom that says \"Available to all users\". Click apply.   也就是链接的这个无限要求输入密码。。。</p>\n\n<p><strong>fedora 17 开机 都会出现  error: file \'/boot/grub2/locale/en.mo.gz\' not found</strong></p>\n\n<p>解决办法。   sudo cp /boot/grub2/locale/uk.mo /boot/grub2/locale/en.mo</p>\n\n<p><strong>markdown 语法中 向这种 的不能现实呀。？？？ 怎么办？</strong></p>\n\n<p>一般来说 markdown 对特殊语法 前加入\"\\\"  即可转议，但是这个却不行，目前解决办法 是在 \"\" 之后加入空格</p>\n\n<p>**如何保障 linux的临时文件目录  一般为/var/temp  或者 /temp **</p>\n\n<p>由于没有另外分区 导致其分区选项与/ 相同 这样 不能更小的粒度。最好 的是 另外一个分区 然后 修改挂在这个分区的选项</p>\n\n<p><strong>PS1 是用来设置命令提示符的环境变量 修改的是 yuanjia@yuanjia-K52Dr:~$ 的格式</strong></p>\n\n<p><strong>ls --color=auto 用来显示ls展示的目录 文本 具有的颜色</strong></p>\n\n<p><strong>可以在 terminal 上使用  control-v 粘帖的一段代码。。这个很好用奥。。</strong></p>\n\n<pre><code># Make Control-v paste, if in X and if xclip available - Josh Triplett\nif [ -n \"$DISPLAY\" ]  [ -x /usr/bin/xclip ] ; then\n    # Work around a bash bug: \\C-@ does not work in a key binding\n    bind \'\"\\C-x\\C-m\": set-mark\'\n    # The \'#\' characters ensure that kill commands have text to work on; if\n    # not, this binding would malfunction at the start or end of a line.\n    bind \'Control-v: \"#\\C-b\\C-k#\\C-x\\C-?\\\"$(xclip -o -selection c)\\\"\\e\\C-e\\C-x\\C-m\\C-a\\C-y\\C-?\\C-e\\C-y\\ey\\C-x\\C-x\\C-d\"\'\nfi\n</code></pre>\n\n<p><strong>alias 命令使用</strong></p>\n\n<p>若仅输入alias，则可列出目前所有的别名设置。　alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在/etc/profile或自己的~/.bashrc中设定指令的别名。\n 例如  alias httpserver=\'python -m SimpleHTTPServer</p>\n\n<p><strong>ubuntu 目录太深？ 向fedora 那样只显示当前目录？</strong></p>\n\n<p>打开 /etc/bash.rc  找到  PS1=\'${debian_ chroot:+($debian_ chroot)}\\u@\\h:\\w\\$ \'  更改为  小写w改为大写W</p>\n\n<p><strong><em>What\'s the command to open a file in GUI?</em></strong></p>\n\n<pre><code>xdg-open filepath\n</code></pre>\n\n<p><strong>关于环境变量。(以下来自larmbr zhan 网友)</strong></p>\n\n<p>LC_*形环境变量的优先级是：LC_ALL  LC_*  LANG.</p>\n\n<p>具体地说，</p>\n\n<blockquote>\n<p><em>1.就是如果定义了LC_ALL ，则它覆盖了所有LC_</em>变量的定义，所有规则都遵从LC_ALL的\n定义。 （注意，这个变量不要设定，它的存在价值可能仅在于定义了一个新locale后，作测试用)</p>\n\n<p><em>2. 如果LC_ALL没设定(合理的方法是应该一直这么做)。则由LC_</em>细粒度地定义了各个方面，\n如关于字符集LC_CTYPE. 关于货币符号LC_MONETARY，关于提示信息LC_MESSAGES等。</p>\n</blockquote>\n\n<p>所以本例中，你应该设定这个变量. 对于GNU家族的工具集，\n  那么如果LC_MESSAGES， 则LANGUAGE值起到和它一样的作用，如你所设。</p>\n\n<blockquote>\n<p><em>3. 如果LC_ALL, 及LC_</em>都没设定，那么会读取 LANG 的设定。</p>\n</blockquote>\n\n<p><strong>about 缓冲区？</strong></p>\n\n<p>windows 的缓冲区只有一个 全局的缓冲区（Clipboard，剪贴板）</p>\n\n<p>*nix (The X server)里面貌似有 4个？(主（Primary）选择，一种是剪贴板（Clipboard）选择。其实还有一个副（Secondary）选择 貌似还有一个 剪切缓冲区 CUT_BUFFER0 在这四个缓冲区中  貌似其中的 副 选择 和  CUT_BUFFER0 已经不太用了。。)  但是 VNC 还是使用的 CUT_BUFFER0  这个缓冲区传递数据。所以这里牵扯了一些同步的问题。。。好多VNC 使用 autocutsel(<a href=\"http://www.nongnu.org/autocutsel/\">http://www.nongnu.org/autocutsel/</a>) 来同步 缓冲区。。。。</p>\n\n<p><strong>shell 脚本传递变量</strong></p>\n\n<pre><code>#!/bin/shell\n#file test.sh\nif [ -z ${PARAM1} ]; then\n    PARAM1=test1\nfi\necho ${PARAM1}\n\nPARAM1=hello sh test.sh\n</code></pre>\n\n<p><strong>关于wget伪装成浏览器的行为 更改user-agent</strong></p>\n\n<p>今天在拔 <a href=\"http://mahua.jser.me/\">http://mahua.jser.me/</a>  网站的css时候遇到了一个问题.. 刚开始使用 wget 下载 js 还可以 然后就不行了..</p>\n\n<p>但是浏览器是可以打开的 这时候 使用</p>\n\n<p>wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 (.NET CLR 3.5.30729)\" <a href=\"http://mahua.jser.me/ace/keybinding-vim.js\">http://mahua.jser.me/ace/keybinding-vim.js</a></p>\n\n<p>成功下载 看来对方使用验证 UA的小计量了......</p>\n\n<p><strong>关于github 项目的语言标签的问题</strong></p>\n\n<p>今天上传了 <a href=\"/xiyoulaoyuanjia/blog/blob/master\">flaskapp</a> 项目时 发现github检测到的项目为javascript(应该为python 更贴切点吧) 于是查了些资料\n<a href=\"http://stackoverflow.com/questions/5318580/how-does-github-figure-out-a-projects-language\">问题看这里</a></p>\n\n<p>检测算法项目<a href=\"https://github.com/github/linguist\">在这里</a>  有时间看看它的这个算法是怎么搞得..不过貌似没有读内容就是查看了后缀?</p>\n\n<p><strong>linux 下图像格式转换</strong></p>\n\n<blockquote>\n<ul>\n<li>convert xiyoulaoyuanjia.png  xiyoulaoyuanjia.gif </li>\n</ul>\n</blockquote>\n\n<p>把 xiyoulaoyuanjia.png 格式转换为  xiyoulaoyuanjia.gif   注意此时 xiyoulaoyuanjia.png 图片格式不变</p>\n\n<blockquote>\n<ul>\n<li>  convert  -resize 16x16! xiyoulaoyuanjia.gif  flaskWeb.gif</li>\n</ul>\n</blockquote>\n\n<p>把  xiyoulaoyuanjia.gif  图片缩小为 16x16 像素的  注意后面的叹号(!)</p>\n\n<p><strong>bash 脚本的几个问题</strong></p>\n\n<p>今天再看 ossec 中的 ossec-control 脚本时遇到的几个问题,这里记录下.</p>\n\n<blockquote>\n<ul>\n<li> \"sudo cat   /var/ossec/var/run/ossec-logcollect*.pid \" 与 su  cat   /var/ossec/var/run/ossec-logcollect*.pid 的区别? </li>\n</ul>\n</blockquote>\n\n<p>当然如果你想着一样那么就错了...至于原因who knows?</p>\n\n<blockquote>\n<ul>\n<li> 脚本中有一段 kill -0 process 干什么呢?</li>\n</ul>\n</blockquote>\n\n<p><a href=\"http://stackoverflow.com/questions/11012527/what-does-kill-0-pid-in-a-shell-script-do\">看这里</a></p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li>1. 查看进程十分running?</li>\n<li>2. 查看进程能否接受信号</li>\n<li>3 \".\" 在shell 中的应用 用来引入环境变量  例如  . 文件名 A  在 A中写 LIANX=\"fff\"</li>\n</ul>\n<blockquote>\n<ul>\n<li>看 ossec 如何使用？</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<pre><code>. ./src/init/update.sh\n    # Is this an update?\n    if [ \"`isUpdate`\" = \"${TRUE}\" -a \"x${USER_CLEANINSTALL}\" = \"x\" ]; then\n        echo \"\"\n        ct=\"1\"\n</code></pre>\n\n<p>isUpdate 在 update.sh 中定义为 一个函数 . 或者 source 之后直接就 可以当作 \n命令使用了</p>\n\n<hr><p><strong>gcc include 查找路径</strong></p>\n\n<p>这里忽略复杂的问题.. /var/include 与 /var/local/include</p>\n\n<hr><p><strong>输入法的问题</strong>*</p>\n\n<blockquote>\n<ul>\n<li>安装 google 输入法 </li>\n</ul>\n<blockquote>\n<ul>\n<li><p>添加源：\nsudo add-apt-repository ppa:fcitx-team/nightly\nsudo apt-get update</p></li>\n<li><p>安装Fcitx、Fcitx-googlepinyin</p></li>\n</ul>\n</blockquote>\n</blockquote>\n\n<p>sudo apt-get install fcitx fcitx-googlepinyin</p>\n\n<blockquote>\n<ul>\n<li>安装 搜狗输入法</li>\n</ul>\n</blockquote>\n\n<p>sudo apt-get install  fcitx-sogoupinyin</p>\n\n<p>貌似在ubuntu的12.10 中有错误。。</p>\n\n<p>im-switch 转换输入法</p>\n\n<hr><p><strong>blkid 有用的一个命令</strong></p>\n\n<p>/dev/sda1: LABEL=\"window 7\" UUID=\"D058935E58934260\" TYPE=\"ntfs\" \n/dev/sda10: LABEL=\"M-eM-(M-1M-dM-9M-^P\" UUID=\"0006E42B000753BB\" TYPE=\"ntfs\" \n/dev/sda5: LABEL=\"M-hM-=M-/M-dM-;M-6\" UUID=\"0007165D000660F4\" TYPE=\"ntfs\" \n/dev/sda7: LABEL=\"_Fedora-17-x86_6\" UUID=\"3b9eea35-98aa-4c24-b255-4f40585079b7\" TYPE=\"ext4\" \n/dev/sda8: LABEL=\"M-fM-^VM-^GM-fM-!M-#\" UUID=\"000A0C6100003D53\" TYPE=\"ntfs\" </p>\n\n<p><strong>安装 Ubuntu restricted extras软件包 包含常用的一些 受限软件 安装完系统之后第一时间可以安装这个</strong></p>\n\n<p><strong>删除除××之外的文件</strong></p>\n\n<p>rm 没有 exclude 选项 考虑使用 管道方式组合使用命令</p>\n\n<p>例如 sudo rm  -f <code>ls | grep -v partial</code></p>\n\n<p>**history 命令 **</p>\n\n<p>之前一直没有使用过这个命令 最近在 <a href=\"http://cloudbbs.org/forum.php?mod=viewthread&tid=13726\">这里</a>\n看到了 感觉挺好用的 这里做一个小总结。。就当作备忘了。</p>\n\n<blockquote>\n<ul>\n<li> history 可以显示 之前执行的命令 但是默认没有时间显示。。如果需要修改此格式可以 \n通过设置 HISTTIMEFORMAT 变量</li>\n</ul>\n</blockquote>\n\n<pre><code>export HISTTIMEFORMAT=\'%F %T \'\n# history | more\n1 2008-08-05 19:02:39 service network restart\n2 2008-08-05 19:02:39 exit\n3 2008-08-05 19:02:39 id\n4 2008-08-05 19:02:39 cat /etc/redhat-release\n</code></pre>\n\n<blockquote>\n<ul>\n<li>ctrl+r 命令的使用</li>\n</ul>\n</blockquote>\n\n<p>这个命令是在consol 里面搜索 之前执行过的命令，找到之后可以直接按 回车键执行。修改 可以按\n左或者右方向键。。\n<a href=\"https://a248.e.akamai.net/camo.github.com/a77ee64d9ced80da050f992b321f54be85afe331/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6538303345384873617561564d61516c546f79685759725472714d463662456e6b62732d2d324664734448674d50734339656c387630783658414c2d2d3242476b744332322d2d324254374f2d2d32467334612d2d32467369374878387278434e666d7252767a6c655265\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/a77ee64d9ced80da050f992b321f54be85afe331/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6538303345384873617561564d61516c546f79685759725472714d463662456e6b62732d2d324664734448674d50734339656c387630783658414c2d2d3242476b744332322d2d324254374f2d2d32467334612d2d32467369374878387278434e666d7252767a6c655265\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<blockquote>\n<ul>\n<li>快速执行上一条命令</li>\n</ul>\n</blockquote>\n\n<p>这里列出了 4条方案</p>\n\n<blockquote>\n<blockquote>\n<ul>\n<li><p>使用上方向键，并回车执行。</p></li>\n<li><p>!! 并回车</p></li>\n<li><p>!-1 并回车</p></li>\n<li><p>按 Ctrl+P 并回车执行</p></li>\n</ul>\n</blockquote>\n\n<ul>\n<li>通过序号执行一个指定的命令</li>\n</ul>\n</blockquote>\n\n<pre><code># !4\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用 HISTSIZE 控制历史命令记录的总行数</li>\n</ul>\n</blockquote>\n\n<p>默认是 500</p>\n\n<blockquote>\n<ul>\n<li>更改默认历史命令记录文本</li>\n</ul>\n</blockquote>\n\n<p>默认情况下，命令历史存储在 ~/.bashhistory 文件中\n更改HISTFILE</p>\n\n<pre><code># vi ~/.bash_profile\nHISTFILE=/root/.lianxi\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用 HISTCONTROL 从命令历史中剔除连续重复的条目</li>\n</ul>\n</blockquote>\n\n<p>export HISTCONTROL=ignoredups</p>\n\n<blockquote>\n<ul>\n<li>清除所有的命令历史</li>\n</ul>\n</blockquote>\n\n<pre><code>history -c\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用 HISTSIZE 禁用 history</li>\n</ul>\n</blockquote>\n\n<pre><code>export HISTSIZE=0\n</code></pre>\n\n<blockquote>\n<ul>\n<li>使用 HISTIGNORE 忽略历史中的特定命令</li>\n</ul>\n</blockquote>\n\n<pre><code> export HISTIGNORE=\"pwd:ls:ls -ltr:\"\n</code></pre>\n\n<p><strong>关于浮点数的小理解</strong></p>\n\n<p>原因，简单的说是因为一些十进制有限小数在2进制中是无限小数。\n解决方法，搜索 decimal</p>\n\n<p>可以看看python 中的解释。\n<a href=\"http://docs.python.org/2/tutorial/floatingpoint.html\">http://docs.python.org/2/tutorial/floatingpoint.html</a></p>\n\n<p><strong>Apt-get GPG Error: Public Key Not Available</strong></p>\n\n<p>看到一篇十分好的<a href=\"http://www.rebelzero.com/fixes/apt-get-gpg-error-public-key-not-available/88\">文章</a></p>\n\n<p>解决这种方法的思路 </p>\n\n<p>wget -q \"<a href=\"http://keyserver.ubuntu.com:11371/pks/lookup?op=get&search=0x4874D3686E80C6B7\">http://keyserver.ubuntu.com:11371/pks/lookup?op=getsearch=0x4874D3686E80C6B7</a>\" -O- | sudo apt-key add -</p>\n\n<p>4874D3686E80C6B7 为 错误id</p>\n\n<p><strong>在shell 中如何判断 一个变量被赋值没有？ 看 ossec 如何实现的？</strong></p>\n\n<pre><code># If user language is not set\n    if [ \"X${USER_LANGUAGE}\" = \"X\" ]; then \n</code></pre>\n\n<p>好吧。我承认这也是一种方法。。。</p>\n\n<p>**shell 中if 的逻辑表达式 **</p>\n\n<pre><code>* 逻辑非 ! \n    if [ ! 表达式 ]\n* 逻辑与 –a  \n    if [ 表达式1  –a  表达式2 ]\n* 逻辑或 -o\n    if [ 表达式1  –o 表达式2 ]\n</code></pre>\n\n<p>可以看ossec中如何使用的</p>\n\n<pre><code># Choosing the language.\n    while [ 1 ]; do\n    echo \"\"\n    for i in `ls ${TEMPLATE}`; do\n        # ignore CVS (should not be there anyways and config)\n        if [ \"$i\" = \"CVS\" -o \"$i\" = \"config\" ]; then continue; fi\n        cat \"${TEMPLATE}/$i/language.txt\"\n        if [ ! \"$i\" = \"en\" ]; then\n            LG=\"${LG}/$i\"\n        fi\n    done\n</code></pre>\n\n<p><strong>在终端下使用vim的命令  注意终端下只有 插入与命令模式</strong></p>\n\n<p>开启 默认是在插入模式下\n     set -o vim \n切换到 命令模式 \n    ESc 键</p>\n\n<p><strong>bash 的 cmd  (subcmd)特殊用法</strong></p>\n\n<p>这是bash的一个特殊构造： cmd  (subcmd) 表示将subcmd输出的管道作为文件传递 给cmd作为参数</p>\n\n<p>例如\ndiff (echo {1..10})  (echo {2..10})</p>\n\n<p>再比如\nls -l (echo {1..10})</p>\n\n<p><strong>443 端口是 https 默认采用的端口</strong></p>\n\n<p>**gcc -Wall   ssl-demo.c -lssl -o ssl-demo 与 gcc -Wall    -lssl ssl-demo.c  -o ssl-demo\n的 区别 **</p>\n\n<p>今天在测试一段 ssl的代码时发现 gcc -Wall   ssl-demo.c -lssl -o ssl-demo 会执行错误\n调整了 -lssl  的顺序之后 正常 。。很是诡异。。。\n测试代码如下：\n<a href=\"https://gist.github.com/xiyoulaoyuanjia/cd2bb25e394d06b92403\">https://gist.github.com/xiyoulaoyuanjia/cd2bb25e394d06b92403</a></p>\n\n<p>这里顺便回忆下动态库的加载顺序 </p>\n\n<blockquote>\n<ul>\n<li>编译目标代码时指定的动态库搜索路径；</li>\n<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径；</li>\n<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径；</li>\n<li>默认的动态库搜索路径/lib；</li>\n<li>默认的动态库搜索路径/usr/lib。</li>\n</ul>\n</blockquote>\n\n<p><strong>What\'s the difference between /sbin/nologin and /bin/false</strong></p>\n\n<p>When /sbin/nologin is set as the shell, if user with that shell logs in, they\'ll get a polite message saying \'This account is currently not available.\'. This message can be changed with the file /etc/nologin.txt.</p>\n\n<p>/bin/false is just a binary that immediately exits, returning false, when its called, so when someone who has false as shell logs in, they\'re immediately logged out when false exits. Setting the shell to /bin/true has the same affect of not allowing someone to log in but false is probably used as a convention over true since its much better at conveying the concept that person doesn\'t have a shell.</p>\n\n<p>Looking at nologin\'s man page, it says it was created in 4.4 BSD (early 1990s) so it came long after false was created. The use of false as a shell is probably just a convention carried over from the early days of UNIX.</p>\n\n<p>nologin is the more user friendly option, with a customizable message given to the user trying to login, so you would theoretically want to use that but both nologin and false will have the same end result of someone not having a shell and not being able to ssh in.</p>\n\n<p><a href=\"http://unix.stackexchange.com/questions/10852/whats-the-difference-between-sbin-nologin-and-bin-false\">orignal link</a></p>\n\n<p><strong>Get UUID of specific connection?</strong></p>\n\n<blockquote>\n<ul>\n<li>\n<p>find the UUID of the current connection</p>\n\n<pre><code>nmcli con status\n</code></pre>\n</li>\n<li>\n<p>list all configured connections</p>\n\n<pre><code>nmcli con list\n</code></pre>\n</li>\n</ul>\n</blockquote>\n\n<p><strong>ubuntu debian 下使用 jekyll</strong></p>\n\n<blockquote>\n<ul>\n<li>sudo apt-get install ruby1.9.1-dev</li>\n<li>gem install jekyll</li>\n</ul>\n</blockquote>\n\n<p><strong>Chrome扩展程序开发：Ajax XmlHttpRequest</strong></p>\n\n<blockquote>\n<ul>\n<li>在插件中使用ajax不受跨域(cross-origin)的限制。</li>\n<li>ajax网络请求需要在manifest.json得到相应域名的permissions.</li>\n</ul>\n</blockquote>\n\n<p><strong>修改左边的unity2d 使它不会自动隐藏?</strong></p>\n\n<p>之前一直在考虑使用 脚本更改设置，今天无意中发现  appearance-》behavior-》auto-hide the launcher 直接更改。而且下面还可以修改灵敏度。。囧。。</p>\n\n<p><strong>应用程序的用户配置文件夹放在~/.config文件夹的原则</strong></p>\n\n<p>之前一直就发现应用程序的配置文件一般都存放在 ~/.config文件夹 下的情况。今天才知道这个原来是 XDG的 标准。是给linux 图形桌面的配置文件的推荐做法。。 更多关于标准的细节可以看<a href=\"http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\">这里</a></p>\n\n<p>早就知道这个XDG (例如XDG-open) 但是还真不知道这个和 linux 桌面有什么关系。今天就查了查原来</p>\n\n<p>XDG stands for X Development Group, which was the old name of FreeDesktop.org:</p>\n\n<p>回到上面。那么这个统一的存放目的有什么用呢？</p>\n\n<p>比如如果你用C实现一个应用程序，GLib有这样的一个函数 g_get_user_config_dir () ：<a href=\"https://developer.gnome.org/glib/2.34/glib-Miscellaneous-Utility-Functions.html#g-get-user-config-dir\">https://developer.gnome.org/glib/2.34/glib-Miscellaneous-Utility-Functions.html#g-get-user-config-dir</a>  用它会直接返回~/.config （如果默认配置是这个的话）。</p>\n\n<p>但是命令行(非桌面) 一般就不按这个标准 例如 git 它的配置文件就直接是 ~/.gitconfig</p>','/xiyoulaoyuanjia/blog/blob/master/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.md','a63bf94458dcea8356aac8fba3c81833-f61804daffd876213b76270c5893bc6c48ade969','<h1>\n<a name=\"linux\" class=\"anchor\" href=\"#linux\"><span class=\"mini-icon mini-icon-link\"></span></a>linux使用记录</h1>'),(21,'关于北邮校园网登录程序.md','<p><strong>关于北邮校园网登录程序</strong></p>\n\n<blockquote>\n<ul>\n<li>这个不是破解认证。仅仅是自动认证。。</li>\n<li>目前支持的热点。。 学十宿舍网  bupt2校内网</li>\n<li>环境为 ubuntu 12.10<br>\n</li>\n<li>程序在<a href=\"https://gist.github.com/xiyoulaoyuanjia/2d63e1b41ec711f8d5e1\">这里</a>\n</li>\n</ul>\n</blockquote>\n\n<p><strong>关于 自动登录</strong></p>\n\n<p>这个使用了 request 相对而言比较简单。。仅仅是把密码 进行了 md5 的加密转换成16进制输出</p>\n\n<p>例如如果想计算自己密码的 加密之后的密文可以按如下操作</p>\n\n<pre><code> import hashlib\n hashlib.md5(\"124\").hexdigest()\n\'c8ffe9a587b126f152ed3d89a146b445\'\n \n</code></pre>\n\n<p><strong>如何做到每次热点接入后自动认证呢？</strong></p>\n\n<p>之前考虑 直接调用 NetworkManager Api <a href=\"http://projects.gnome.org/NetworkManager/\">这里</a>  操作 \n当然这样可以做的事情就比较多了。。而且还看了 python 的<a href=\"http://cgit.freedesktop.org/NetworkManager/NetworkManager/tree/examples/python\">demo</a> \n感激非常的棒</p>\n\n<p>后来 在网上看到 这个<a href=\"http://t.du9l.com/post/40\">资料</a> 觉得不错。。 这里感谢这个作者\n后来就直接拿过来用了。。至少现在可以满足我的要求。</p>\n\n<blockquote>\n<ul>\n<li>下载下来放到 /etc/NetworkManager/dispatcher.d/ 中</li>\n<li>注意修改可执行文件</li>\n</ul>\n</blockquote>\n\n<p><strong>关于登录成功的窗口通知</strong></p>\n\n<p>本想着这个可能十分简单的事情。。谁知道 确实花费时间最多的。。</p>\n\n<p>“问题是我需要执行的脚本会执行 。。但是里面的 zenity弹出框怎么也不出来。。\n为了排除是python的脚本问题。。我直接把命令放在了shell里面。也还是没有结果。。。。 \n我已经查看了 networking 的日志  </p>\n\n<p>nm-dispatcher.action: Script  exited with error status 1”`</p>\n\n<p>后来在以为邮件列表中的网友的帮助下。。</p>\n\n<p>修改了之前的程序。。\n方法如下:</p>\n\n<blockquote>\n<ul>\n<li>增加环境变量</li>\n</ul>\n</blockquote>\n\n<pre><code>export DISPLAY=:0 \n</code></pre>\n\n<blockquote>\n<ul>\n<li>增加 对 x的访问权限</li>\n</ul>\n</blockquote>\n\n<pre><code>xhost local: 1/dev/null\n</code></pre>\n\n<p>这里参考了一些资料</p>\n\n<p><a href=\"http://www.leidinger.net/X/xhost.html\">xhost</a></p>\n\n<p><a href=\"http://promberger.info/linux/2009/01/02/running-x-apps-like-zenity-from-crontab-solving-cannot-open-display-problem/\">cannot-open-display-problem</a></p>\n\n<p>算是解决了吧。。如下图</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/e6dbd580e4b026fad88161a7e8328acd1898cd51/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6233643334342d2d3246784c6b7449506d5556516e364b74626a6242436c764c427832414d5a3374432d2d32426c7732632d2d32466871326256446f37476759647037664c4b774a4e67374b3277454f476650715039644856574c30577a756a446476455a\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/e6dbd580e4b026fad88161a7e8328acd1898cd51/687474703a2f2f6f70656e6170692e766469736b2e6d652f3f6d3d66696c6526613d646f776e6c6f61645f73686172655f66696c652673733d6233643334342d2d3246784c6b7449506d5556516e364b74626a6242436c764c427832414d5a3374432d2d32426c7732632d2d32466871326256446f37476759647037664c4b774a4e67374b3277454f476650715039644856574c30577a756a446476455a\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>对于 第二个有一个小问题。。现在是把上述命令放在了 startup application(ubuntu) 中 每次开机都需要运行上述命令。。\n这个不能记录更改操作吗？  好吧。。这个先留着。。。</p>\n\n<p><strong>关于bupt2校内网</strong></p>\n\n<p>这个是最简单的。但也是花费我时间最长的一个。。</p>\n\n<p>之前一直是用 python的requests 库做的。。</p>\n\n<p>测试requests 如下:</p>\n\n<pre><code> requests.post(url,data={\"PtUser\":111,\"PtPwd\":33})\nTraceback (most recent call last):\n  File \"stdin\", line 1, in module\n  File \"/usr/local/lib/python2.7/dist-packages/requests/api.py\", line 88, in post\n    return request(\'post\', url, data=data, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/requests/api.py\", line 44, in request\n    return session.request(method=method, url=url, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/requests/sessions.py\", line 354, in request\n    resp = self.send(prep, **send_kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/requests/sessions.py\", line 460, in send\n    r = adapter.send(request, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/requests/adapters.py\", line 246, in send\n    raise ConnectionError(e)\nrequests.exceptions.ConnectionError: HTTPConnectionPool(host=\'10.8.128.1\', port=80): Max retries exceeded with url: /portal/logon.cgi (Caused by class \'httplib.BadStatusLine\': \'\')\n \n</code></pre>\n\n<p>于是顺着 Caused by : 错误 </p>\n\n<pre><code>exception httplib.BadStatusLine\nA subclass of HTTPException. Raised if a server responds with a HTTP status code that we don’t understand.\n</code></pre>\n\n<p>以为是服务器发送了不认识的状态吗 的思路考虑 以为是服务器block 爬虫..后来各种header 各种 UA 尝试均不成功</p>\n\n<p>不行，后来用 wget测试如下 </p>\n\n<pre><code>wget --post-data \"PtUser=111PtPwd=33\" --header=\"User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31\" --header=\"Referer: http://10.8.128.1/portal/logon.cgi?userip=10.8.160.134userurl=687474703a2f2f31302e332e382e323131\" --header=\"Cookie: LPTSRVID=1202120206; lang=0\" --header=\"Origin: http://10.8.128.1\" --header=\"Host: 10.8.128.1\"   http://10.8.128.1/portal/logon.cgi \n\n\nConnecting to 10.8.128.1:80... connected. \nHTTP request sent, awaiting response... No data received. \nRetrying. \n\n--2013-04-19 10:21:44--  (try: 2)  http://10.8.128.1/portal/logon.cgi \nConnecting to 10.8.128.1:80... connected. \nHTTP request sent, awaiting response... No data received. \nRetrying. \n</code></pre>\n\n<p>才发现是服务器端没有回应。。。</p>\n\n<p>于是从新从chrome 看post 数据。。终于。。发现 post 少传了一个参数 PtButton 导致。。。唉。。。</p>\n\n<p>修改之后终于完美got it</p>','/xiyoulaoyuanjia/blog/blob/master/%E5%85%B3%E4%BA%8E%E5%8C%97%E9%82%AE%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E7%A8%8B%E5%BA%8F.md','81240ee240f3b29e9cd6ad917b2e649f-3a1aed1cc0d342069478656b738c761c38d5ead9','<p><strong>关于北邮校园网登录程序</strong></p>'),(22,'python 描述符.md','<h1>\n<a name=\"python-\" class=\"anchor\" href=\"#python-\"><span class=\"mini-icon mini-icon-link\"></span></a>python 描述符</h1>\n\n<p>访问一个属性的优先级顺序</p>\n\n<blockquote>\n<ul>\n<li>类属性</li>\n<li>数据描述符</li>\n<li>实例属性</li>\n<li>非数据描述符</li>\n<li>\n<strong>getattr</strong>方法</li>\n</ul>\n</blockquote>\n\n<p><strong>关于数据描述符的定义</strong></p>\n\n<p>实现了 __get__  __set__  __del__  方法的类属性</p>\n\n<p><strong>关于非数据描述符的定义</strong></p>\n\n<p>所有的类数据函数都是非数据描述符</p>\n\n<pre><code>__get__(self,obj,type=None)\n__set__(self,obj,val)\n__del__(self,obj)\n</code></pre>\n\n<p>其中 self 是调用它的实例,访问属性的方法。</p>\n\n<p>对于给定的类X和实例x </p>\n\n<p>X.foo 等价于</p>\n\n<pre><code>type(x).__dict__[\"foo\"].__get__(None,type(x))\n</code></pre>\n\n<p>x.foo 等价于\n    type(x).__dict__[\"foo\"].__get__(x,type(x))</p>\n\n<p><strong>先看类属性</strong></p>\n\n<pre><code> class A(object):\n...     foo=1.2\n... \n A.__dict__\ndict_proxy({\'__dict__\': attribute \'__dict__\' of \'A\' objects, \'__module__\': \'__main__\', \'foo\': 1.2, \'__weakref__\': attribute \'__weakref__\' of \'A\' objects, \'__doc__\': None})\n</code></pre>\n\n<p>可以看到在类的dict属性里</p>\n\n<p><strong>实例属性</strong></p>\n\n<p><strong>数据描述符</strong></p>\n\n<pre><code>class simpleDescriptor(object):\n   def __get__(self,obj,type=None) :\n       pass;\n   def __set__(self,obj,val):\n       pass;\n   def __del__(self,obj):\n       pass\nclass A(object):\n    foo=simpleDescriptor();\n\n a=A();\n print a.foo;\nNone\n a.foo=13;\n print a.foo;\nNone\n \n</code></pre>\n\n<p>原因在于 get 与set 方法都没有实体方法</p>\n\n<p><strong>note:Python在实在找不到方法的时候，就会求助于__getattr__方法</strong></p>','/xiyoulaoyuanjia/blog/blob/master/python%20%E6%8F%8F%E8%BF%B0%E7%AC%A6.md','7bd1eaa0418930ae85c9cd3029663fbb-f12b296e6966bbe0e06b66ee2de773cb7d8b9eaf','<h1>\n<a name=\"python-\" class=\"anchor\" href=\"#python-\"><span class=\"mini-icon mini-icon-link\"></span></a>python 描述符</h1>\n\n<p>访问一个属性的优先级顺序</p>\n\n<blockquote>\n<ul>\n<li>类属性</li>\n<li>数据描述符</li>\n<li>实例属性</li>\n<li>非数据描述符</li>\n<li>\n<strong>getattr</strong>方法</li>\n</ul>\n</blockquote>\n\n<p><strong>关于数据描述符的定义</strong></p>\n\n<p>实现了 __get__  __set__  __del__  方法的类属性</p>\n\n<p><strong>关于非数据描述符的定义</strong></p>\n\n<p>所有的类数据函数都是非数据描述符</p>\n\n<pre><code>__get__(self,obj,type=None)\n__set__(self,obj,val)\n__del__(self,obj)\n</code></pre>\n\n<p>其中 self 是调用它的实例,访问属性的方法。</p>\n\n<p>对于给定的类X和实例x </p>\n\n<p>X.foo 等价于</p>\n\n<pre><code>type(x).__dict__[\"foo\"].__get__(None,type(x))\n</code></pre>\n\n<p>x.foo 等价于\n    type(x).__dict__[\"foo\"].__get__(x,type(x))</p>\n\n<p><strong>先看类属性</strong></p>\n\n<pre><code> class A(object):\n...     foo=1.2\n... \n A.__dict__\ndict_proxy({\'__dict__\': attribute \'__dict__\' of \'A\' objects, \'__module__\': \'__main__\', \'foo\': 1.2, \'__weakref__\': attribute \'__weakref__\' of \'A\' objects, \'__doc__\': None})\n</code></pre>\n\n<p>可以看到在类的dict属性里</p>\n\n<p><strong>实例属性</strong></p>\n\n<p><strong>数据描述符</strong></p>\n\n<pre><code>class simpleDescriptor(object):\n   def __get__(self,obj,type=None) :\n       pass;\n   def __set__(self,obj,val):\n       pass;\n   def __del__(self,obj):\n       pass\nclass A(object):\n    foo=simpleDescriptor();\n\n a=A();\n print a.foo;\nNone\n a.foo=13;\n print a.foo;\nNone\n \n</code></pre>\n\n<p>原因在于 get 与set 方法都没有实体方法</p>\n\n<p><strong>note:Python在实在找不到方法的时候，就会求助于__getattr__方法</strong></p>'),(23,'git 使用.md','<h1>\n<a name=\"git-\" class=\"anchor\" href=\"#git-\"><span class=\"mini-icon mini-icon-link\"></span></a>git 使用</h1>\n\n<p><a href=\"http://rogerdudler.github.com/git-guide/index.zh.html\">参考这里</a></p>\n\n<hr><p><strong>安装</strong></p>\n\n<p><a href=\"http://code.google.com/p/git-osx-installer/downloads/list?can=3\"><em>git osx 版本</em></a></p>\n\n<p><a href=\"http://code.google.com/p/msysgit/downloads/list?can=3\">git windows 版本</a></p>\n\n<p><a href=\"http://book.git-scm.com/2_installing_git.html\">git linux版本</a></p>\n\n<hr><p><strong>创建新仓库</strong></p>\n\n<pre><code>1.创建新文件夹\n2.进入执行 git init\n</code></pre>\n\n<hr><p><strong>复制仓库</strong></p>\n\n<blockquote>\n<ul>\n<li>复制本地仓库</li>\n</ul>\n<blockquote>\n<pre><code> git clone /path/to/repository\n</code></pre>\n\n<p>/path/to/repository 是本地的仓库地址</p>\n</blockquote>\n\n<ul>\n<li>复制网络上的仓库</li>\n</ul>\n<blockquote>\n<pre><code> git clone username@host:/path/to/repository\n</code></pre>\n\n<p>username@host:/path/to/repository 在github上面  是<a href=\"https://github.com/xiyoulaoyuanjia/AboutWeb.git\">https://github.com/xiyoulaoyuanjia/AboutWeb.git</a> 表示其走http协议 如果是<a href=\"mailto:git@github.com\">git@github.com</a>:xiyoulaoyuanjia/AboutWeb.git 表示走 ssh协议  git://github.com/xiyoulaoyuanjia/AboutWeb.git  则表示走的时git协议</p>\n</blockquote>\n</blockquote>\n\n<hr><p><strong>工作流</strong></p>\n\n<p>git在本地维护着3棵树 。分别是工作目录(实际的文件)、缓冲区(保存最近的更改)、最后是HEAD(指向最近提交的内容)</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/08972dafe10bf148fb7ed7b97e75ead9654ac5f0/687474703a2f2f726f6765726475646c65722e6769746875622e636f6d2f6769742d67756964652f696d672f74726565732e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/08972dafe10bf148fb7ed7b97e75ead9654ac5f0/687474703a2f2f726f6765726475646c65722e6769746875622e636f6d2f6769742d67756964652f696d672f74726565732e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<hr><p><strong>添加与提交</strong></p>\n\n<p>把修改的东西添加到缓冲区</p>\n\n<pre><code>git add file\n</code></pre>\n\n<p>实际提交使用如下命令提交到 HEAD 处</p>\n\n<pre><code>git commit -m \"代码提交信息\"\n</code></pre>\n\n<p>但是这样没有提交到远程服务器中</p>\n\n<hr><p><strong>推送改动</strong></p>\n\n<p>将本地的改动推送到远程的仓库上的命令</p>\n\n<pre><code>git push origin master\n</code></pre>\n\n<p>master 表示远程的分支(主分支与其它的分支)</p>\n\n<p>如果没有克隆远程的仓库。只是向将现有的仓库增加到远程的仓库里可以使用如下命令</p>\n\n<pre><code>git remote add origin server(例如git@github.com:xiyoulaoyuanjia/AboutWeb.git)\n</code></pre>\n\n<hr><p><strong>分支</strong></p>\n\n<p>分支是用来将特性开发绝缘的。新建仓库的时候 master是默认的主仓库、可以在其它仓库上面开发、待开发完成之后再将它们合并到主分区上面去。</p>\n\n<p><a href=\"https://a248.e.akamai.net/camo.github.com/29baef3644852a2fe2ea860551b088e0c24557e7/687474703a2f2f726f6765726475646c65722e6769746875622e636f6d2f6769742d67756964652f696d672f6272616e636865732e706e67\" target=\"_blank\"><img src=\"https://a248.e.akamai.net/camo.github.com/29baef3644852a2fe2ea860551b088e0c24557e7/687474703a2f2f726f6765726475646c65722e6769746875622e636f6d2f6769742d67756964652f696d672f6272616e636865732e706e67\" alt=\"\" style=\"max-width:100%;\"></a></p>\n\n<p>创建分支可以使用 git checkout 命令  例如 创建一个feature_x分支并切换过去</p>\n\n<pre><code>git checkout -b feature_x\n</code></pre>\n\n<p>切换回主分区</p>\n\n<pre><code>git checkout master\n</code></pre>\n\n<p>删除新建的分支</p>\n\n<pre><code>git branch -d feature_x\n</code></pre>\n\n<p><strong>更新与合并</strong>   </p>\n\n<blockquote>\n<p>更新本地仓库</p>\n\n<blockquote>\n<p>1.更新远程仓库到本地仓库</p>\n\n<pre><code> git pull\n</code></pre>\n\n<p>2.更新其它分支到主分支(例如master)</p>\n\n<pre><code> git merge branch\n</code></pre>\n</blockquote>\n\n<p>合并冲突</p>\n\n<p>这个对于复杂的问题需要手动合并冲去。当然 少不了一些常用的工具 git diff A B</p>\n</blockquote>\n\n<p><strong>标签</strong></p>\n\n<p>在软件发布的时候创建标签是被推荐的。。</p>\n\n<pre><code>git tag 1.0.0 1b2e1d63ff\n</code></pre>\n\n<p>1b2e1d63ff 是commit的提交ID 当然可以少 只要是唯一的就行。。 查看ID 使用</p>\n\n<pre><code>git log\n</code></pre>\n\n<p><strong>替换本地改动</strong></p>\n\n<p>回到之前的改动。。</p>\n\n<pre><code>git checkout -- filename\n</code></pre>\n\n<p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响</p>\n\n<p>另外如果想修改本地的所有改动。去服务器下载最新版本 然后把本地主分区指向它就行 相应的命令为</p>\n\n<pre><code>git fetch origin\ngit reset --hard origin/master\n</code></pre>\n\n<p><strong>有用的东西</strong></p>\n\n<p>内建的图形化 git</p>\n\n<pre><code>gitk\n</code></pre>','/xiyoulaoyuanjia/blog/blob/master/git%20%E4%BD%BF%E7%94%A8.md','53a603ea6c416a503a23e3e82c4f594a-e0c7713aad276bc4d9961b26fed399664fc4c7a9','<h1>\n<a name=\"git-\" class=\"anchor\" href=\"#git-\"><span class=\"mini-icon mini-icon-link\"></span></a>git 使用</h1>\n\n<p><a href=\"http://rogerdudler.github.com/git-guide/index.zh.html\">参考这里</a></p>'),(24,'gcc.md','<p>gcc 4.6 加了两个warning </p>\n\n<p>当程序中出现已经赋值的但并未使用过的变量时，GCC会触发 -Wunused-but-set-variable 的警告；当程序中某个函数参数没有在函数中使用过时，GCC会触发 -Wunused-but-set-parameter 警告。这两个警告可以用 -Wall 和 -Wextra 触发。</p>\n\n<p>有时候开发者需要在调试过程中定义一些虽已赋值，但并不使用的变量，或者定义一些在后续版本中要使用到的函数参数。可又不能不用 -Wall -Wextra 这两个选项来编译</p>\n\n<p>使用 <strong>attribute</strong> ((unused)) 避免上述__attribute__ ((unused)) a</p>\n\n<p>例如   <strong>attribute</strong> ((unused)) a  则a 可以定义但是不使用 或者 参数但是不使用</p>','/xiyoulaoyuanjia/blog/blob/master/gcc.md','2051b9beaf1333d581c9d28c731ff910-a6bd4db1763a19fd4d065b9a2146ece2adb2e9d0','<p>gcc 4.6 加了两个warning </p>\n\n<p>当程序中出现已经赋值的但并未使用过的变量时，GCC会触发 -Wunused-but-set-variable 的警告；当程序中某个函数参数没有在函数中使用过时，GCC会触发 -Wunused-but-set-parameter 警告。这两个警告可以用 -Wall 和 -Wextra 触发。</p>\n\n<p>有时候开发者需要在调试过程中定义一些虽已赋值，但并不使用的变量，或者定义一些在后续版本中要使用到的函数参数。可又不能不用 -Wall -Wextra 这两个选项来编译</p>\n\n<p>使用 <strong>attribute</strong> ((unused)) 避免上述__attribute__ ((unused)) a</p>\n\n<p>例如   <strong>attribute</strong> ((unused)) a  则a 可以定义但是不使用 或者 参数但是不使用</p>'),(25,'strace.md','<h1>\n<a name=\"linux-strace-\" class=\"anchor\" href=\"#linux-strace-\"><span class=\"mini-icon mini-icon-link\"></span></a>linux strace 命令学习</h1>\n\n<p><strong>什么是strace？</strong></p>\n\n<p>strace – trace system calls and signals 系统调用与系统信号分析</p>\n\n<p>strace 最简单的用法就是后接一个进程，进程执行完成之后strace也就退出了。strace会在进程执行中解析进程的所有系统调用与系统信号分析</p>\n\n<hr><p><strong>追踪系统调用</strong></p>\n\n<pre><code>strace ./test\n</code></pre>\n\n<p>会输出test程序的所有系统调用(默认格式)</p>\n\n<p><strong>追踪信号传递</strong></p>\n\n<p>我们可以通过一个strace的输出来看</p>\n\n<pre><code> set_thread_area({entry_number:-1 - 6, base_addr:0xbf5ee740, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmunmap(0xbf5ef000, 65900)               = 0\nfstat64(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xbf5ff000\nread(0, 0xbf5ff000, 1024)               = ? ERESTARTSYS (To be restarted)\n--- SIGTERM (Terminated) @ 0 (0) ---\n+++ killed by SIGTERM +++\n</code></pre>\n\n<p>当然 这只是strace输出的一部分了。在最后我们可以看到killed by SIGTER表示接受到了一个 SIGTERM 信号。</p>\n\n<p><strong>系统调用统计</strong></p>\n\n<p>strace不光能分析系统调用，还可以将系统调用做一个统计分析 我们依旧可以从一个strace 的结果来看</p>\n\n<pre><code>strace -c ./test\n\n execve(\"./test\", [\"./test\"], [/* 41 vars */]) = 0\n% time     seconds  usecs/call     calls    errors syscall\n------ ----------- ----------- --------- --------- ----------------\n 45.90    0.000140           5        27        25 open\n 34.43    0.000105           4        24        21 stat64\n  7.54    0.000023           5         5           old_mmap\n  2.62    0.000008           8         1           munmap\n  1.97    0.000006           6         1           uname\n  1.97    0.000006           2         3           fstat64\n  1.64    0.000005           3         2         1 read\n  1.31    0.000004           2         2           close\n  0.98    0.000003           3         1           brk\n  0.98    0.000003           3         1           mmap2\n  0.66    0.000002           2         1           set_thread_area\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.000305                    68        47 total\n</code></pre>\n\n<p>上面输出的统计信息已经很详细了。这对于我们分析程序而言十分有帮助。</p>\n\n<hr><p><strong>重定向输出</strong></p>\n\n<pre><code>strace -c -o test.txt ./test\n</code></pre>\n\n<p><strong>对系统调用进行计时</strong></p>\n\n<pre><code>strace -T ./test\n</code></pre>\n\n<p><strong>系统调用的时间</strong></p>\n\n<p>只要使用-t/tt/ttt三个参数就可以看到效果了，具体的例子可以自己去尝试</p>\n\n<p><strong>截断输出</strong></p>\n\n<pre><code>strace -s 20 ./test\n</code></pre>\n\n<p>每一行不超过20个字符</p>\n\n<p><strong>strace一个已经运行的进程</strong></p>\n\n<pre><code>strace -p pid\n</code></pre>\n\n<p>pid 表示一个已经运行的程序的pid.</p>\n\n<hr><p><strong>一个综合例子</strong></p>','/xiyoulaoyuanjia/blog/blob/master/strace.md','7f90d0ce5744b8497ecb643f139aab04-cef96cda8c626ac98f385a1ae211d9d18e509b95','<h1>\n<a name=\"linux-strace-\" class=\"anchor\" href=\"#linux-strace-\"><span class=\"mini-icon mini-icon-link\"></span></a>linux strace 命令学习</h1>\n\n<p><strong>什么是strace？</strong></p>\n\n<p>strace – trace system calls and signals 系统调用与系统信号分析</p>\n\n<p>strace 最简单的用法就是后接一个进程，进程执行完成之后strace也就退出了。strace会在进程执行中解析进程的所有系统调用与系统信号分析</p>'),(26,'python 编码问题.md','<blockquote>\n<ul>\n<li>python 安装时默认的编码方式 为 ascii方式</li>\n</ul>\n</blockquote>\n\n<pre><code> print sys.getdefaultencoding()\nascii\n</code></pre>\n\n<blockquote>\n<ul>\n<li>修改默认编码方式 \nreload(sys)\nsys.setdefaultencoding(\'utf8\')</li>\n</ul>\n</blockquote>\n\n<p>注意这里的 reload(sys) 的问题  详细见<a href=\"https://groups.google.com/forum/?fromgroups=#!topic/comp.lang.python/hUsco3ZvR2s\">这里</a></p>\n\n<blockquote>\n<ul>\n<li>常见的两种编码方式</li>\n</ul>\n</blockquote>\n\n<pre><code> \"汉字\".__class__\ntype \'str\'\n \n u\"汉字\".__class__\ntype \'unicode\'\n \n</code></pre>\n\n<p>str 与 unicode 有什么区别呢？?</p>\n\n<blockquote>\n<ul>\n<li> \"你好\".encode(\"utf8\") 错误的分析</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>\"你好\".encode(\"utf8\")</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<pre><code>Traceback (most recent call last):\nFile \"stdin\", line 1, in module\nUnicodeDecodeError: \'ascii\' codec can\'t decode byte 0xe4 in position 0: ordinal not in range(128)\n</code></pre>\n\n<p>更完整的关于这个的错误解释见<a href=\"http://stackoverflow.com/questions/9644099/python-ascii-codec-cant-decode-byte\">这里</a></p>\n\n<blockquote>\n<ul>\n<li>关于 decode 方法 的使用</li>\n</ul>\n</blockquote>\n\n<pre><code> \"汉字\".decode()\nTraceback (most recent call last):\n  File \"stdin\", line 1, in module\nUnicodeDecodeError: \'ascii\' codec can\'t decode byte 0xe6 in position 0: ordinal not in range(128)\n \n</code></pre>\n\n<p>decode 默认会把 \"汉字\" 转化为 系统编码(因为默认为ascii所以上述会出错)，验证可以更改系统\n编码之后在测试上面的</p>\n\n<pre><code> import sys\n sys.getdefaultencoding()\n\'ascii\'\n \n reload(sys)\nmodule \'sys\' (built-in)\n sys.setdefaultencoding(\'utf8\') \n \"汉字\".decode()\nu\'\\u6c49\\u5b57\'\n \n</code></pre>\n\n<p>如果不想这样子可以直接 \"汉字\".decode(\"utf8\") 这样子编码</p>\n\n<blockquote>\n<ul>\n<li>关于编码转换</li>\n</ul>\n</blockquote>\n\n<p>一般转换思路为 A编码--》系统编码(Asci或者unicode)--》B编码</p>\n\n<p>因为系统默认编码方式一般是 Ascii所以 对于A编码能不能转化为 ASCII 为关键。而我们知道\n编码问题的大多数错误都是在这里出粗了</p>\n\n<p>例如  \"你好\".encode(\"utf8\")</p>\n\n<p>按上述转换思路可以看出 \"你好\".decode().encode(\"utf8\")</p>\n\n<p>\"你好\" 的编码有外部文本环境决定 例如 # -*- coding: utf-8 -*-  则 编码为 utf8\n而此时系统编码为 默认的ASCii  所以第一步 utf8--》 ASii 编码 肯定会错误的。。</p>\n\n<p>这里写了一个通用的转换代码</p>\n\n<pre><code>#!/usr/bin/env python \n#coding=utf-8 \ns=\"中文\" \nif isinstance(s, unicode):  \nprint s.encode(\'gb2312\') \nelse: \nprint s.decode(\'utf-8\').encode(\'gb2312\')\n</code></pre>\n\n<p>这里编码已gb2321 为例子</p>','/xiyoulaoyuanjia/blog/blob/master/python%20%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.md','c372556945ca921c2ef2ee33954a421f-2469d58658f01ce516cf3e11d7daca5350cbfbb7','<blockquote>\n<ul>\n<li>python 安装时默认的编码方式 为 ascii方式</li>\n</ul>\n</blockquote>\n\n<pre><code> print sys.getdefaultencoding()\nascii\n</code></pre>\n\n<blockquote>\n<ul>\n<li>修改默认编码方式 \nreload(sys)\nsys.setdefaultencoding(\'utf8\')</li>\n</ul>\n</blockquote>\n\n<p>注意这里的 reload(sys) 的问题  详细见<a href=\"https://groups.google.com/forum/?fromgroups=#!topic/comp.lang.python/hUsco3ZvR2s\">这里</a></p>\n\n<blockquote>\n<ul>\n<li>常见的两种编码方式</li>\n</ul>\n</blockquote>\n\n<pre><code> \"汉字\".__class__\ntype \'str\'\n \n u\"汉字\".__class__\ntype \'unicode\'\n \n</code></pre>\n\n<p>str 与 unicode 有什么区别呢？?</p>\n\n<blockquote>\n<ul>\n<li> \"你好\".encode(\"utf8\") 错误的分析</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>\"你好\".encode(\"utf8\")</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<pre><code>Traceback (most recent call last):\nFile \"stdin\", line 1, in module\nUnicodeDecodeError: \'ascii\' codec can\'t decode byte 0xe4 in position 0: ordinal not in range(128)\n</code></pre>\n\n<p>更完整的关于这个的错误解释见<a href=\"http://stackoverflow.com/questions/9644099/python-ascii-codec-cant-decode-byte\">这里</a></p>\n\n<blockquote>\n<ul>\n<li>关于 decode 方法 的使用</li>\n</ul>\n</blockquote>\n\n<pre><code> \"汉字\".decode()\nTraceback (most recent call last):\n  File \"stdin\", line 1, in module\nUnicodeDecodeError: \'ascii\' codec can\'t decode byte 0xe6 in position 0: ordinal not in range(128)\n \n</code></pre>\n\n<p>decode 默认会把 \"汉字\" 转化为 系统编码(因为默认为ascii所以上述会出错)，验证可以更改系统\n编码之后在测试上面的</p>\n\n<pre><code> import sys\n sys.getdefaultencoding()\n\'ascii\'\n \n reload(sys)\nmodule \'sys\' (built-in)\n sys.setdefaultencoding(\'utf8\') \n \"汉字\".decode()\nu\'\\u6c49\\u5b57\'\n \n</code></pre>\n\n<p>如果不想这样子可以直接 \"汉字\".decode(\"utf8\") 这样子编码</p>\n\n<blockquote>\n<ul>\n<li>关于编码转换</li>\n</ul>\n</blockquote>\n\n<p>一般转换思路为 A编码--》系统编码(Asci或者unicode)--》B编码</p>\n\n<p>因为系统默认编码方式一般是 Ascii所以 对于A编码能不能转化为 ASCII 为关键。而我们知道\n编码问题的大多数错误都是在这里出粗了</p>\n\n<p>例如  \"你好\".encode(\"utf8\")</p>\n\n<p>按上述转换思路可以看出 \"你好\".decode().encode(\"utf8\")</p>\n\n<p>\"你好\" 的编码有外部文本环境决定 例如 # -*- coding: utf-8 -*-  则 编码为 utf8\n而此时系统编码为 默认的ASCii  所以第一步 utf8--》 ASii 编码 肯定会错误的。。</p>\n\n<p>这里写了一个通用的转换代码</p>\n\n<pre><code>#!/usr/bin/env python \n#coding=utf-8 \ns=\"中文\" \nif isinstance(s, unicode):  \nprint s.encode(\'gb2312\') \nelse: \nprint s.decode(\'utf-8\').encode(\'gb2312\')\n</code></pre>\n\n<p>这里编码已gb2321 为例子</p>');
/*!40000 ALTER TABLE `blog_entries` ENABLE KEYS */;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-05-06 10:32:57
